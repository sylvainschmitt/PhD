---
title: "A08 : Interaction Model"
date: '`r Sys.Date()`'
author: Sylvain Schmitt & Anne Baranger
output:
  bookdown::html_document2:
    number_sections: no
    toc: true
    toc_float: yes
    theme: flatly
  bookdown::pdf_document2:
    includes:
      before_body: ./template/doc_prefix.tex
      in_header: ./template/preamble.tex
    number_sections: false
    toc: false
    keep_tex: true
  bookdown::word_document2: default
linestretch: 1.5
# csl: /home/ECOFOG/sylvain.schmitt/Documents/Bibliography/csl/mee.csl
# bibliography: /home/ECOFOG/sylvain.schmitt/Documents/Bibliography/library.bib
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
#rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(tidyverse)
library(kableExtra)
if(knitr:::is_html_output()) options(knitr.table.format = "html") 
if(knitr:::is_latex_output()) options(knitr.table.format = "latex") 
library(rstan)
library(bayesplot)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 6,
  cache = T, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
path <- "../../data/Paracou/"
```

```{r data, eval=T}
# traitsSymphonia <- googlesheets::gs_title("Measures_Symphonia") %>%
#   googlesheets::gs_read("AllTraits") %>%
#   mutate(SLA = as.numeric(SLA), LDMC = as.numeric(LDMC)) %>%
#   mutate(Genus = "Symphonia") %>%
#   rename(Species = Morphotype) %>%
#   mutate(Species = ifelse(Species == "Indet.",
#                           c("globulifera", "sp.1", "sp.1")[fct_recode(Bark, "globulifera" = "G",
#                                      "sp.1" =  "S")], Species))
# traitsEschweilera <- googlesheets::gs_title("Measures_Eschweilera") %>%
#   googlesheets::gs_read("AllTraits") %>%
#   filter(!(Plot == 14 & SubPlot == 1 & TreeFieldNum == 760)) %>%  # outlier
#   filter(!(Species %in% c("congestiflora","simiorum","persistens")))
# traits <- bind_rows(traitsEschweilera, traitsSymphonia) %>%
#   mutate(SpeciesLong = paste(substr(Genus, 1, 1), Species)) %>%
#   group_by(idTree, Plot, SubPlot, TreeFieldNum, Genus, Species,
#            SpeciesLong, Bark, Dawkins) %>%
#   summarise_at(vars("SLA", "LDMC", "LT", "LA", "CC",
#                     "brBT", "brBD", "brWD"), mean, na.rm = T) %>%
#   ungroup() %>%
#   mutate(invSLA=1/SLA) %>%
#   mutate(invLA=1/LA)
# load("./functional_save/env.Rdata")
# Individuals <-  left_join(traits, env, by = "idTree", suffix = c("", ".y"))
# rm(traitsEschweilera, traitsSymphonia, traits, paracou, env)
# save(Individuals, file = "./functional_save/Individuals.Rdata")
load("./functional_save/Individuals.Rdata")
load("./functional_save/CompetitionMatrix.Rdata")
```

# Introduction {-}

The aim of this document is to fit the interaction full model with observed values of functional traits for our individuals. We prepared data excluding oultiers and reducing variance of all continuous variable to ease model fit (see figure \@ref(fig:mdata)). We tested the full model with additive (1) and hierarchical (2) forms.

```{r mdata}
traits <- c("invSLA", "LDMC", "LT", "invLA", "CC")
mdata <- lapply(traits, function(trait){
  data_trait <- Individuals[!is.na(unlist(Individuals[,trait])),] %>% 
    left_join(select(Competition, idTree, AreaOutside20) 
              %>% unique())
  Competition_trait <- Competition
  Competition_trait$idTree <- match(Competition_trait$idTree, data_trait$idTree)
  Competition_trait <- filter(Competition_trait, !is.na(idTree))
  list(Model = trait,
       N = nrow(data_trait),
       J = nrow(Competition_trait),
       C = length(unique(data_trait$Genus)),
       S = length(unique(data_trait$Species)),
       Trait = unlist(data_trait[trait])/sd(unlist(data_trait[trait])),
       DBH = data_trait$DBH/sd(data_trait$DBH),
       TWI = data_trait$TWI/sd(data_trait$TWI),
       DBHj = Competition_trait$DBHj/sd(Competition_trait$DBHj),
       Deltaj = Competition_trait$dij/sd(Competition_trait$dij),
       weights = 1-data_trait$AreaOutside20,
       individual = as.numeric(as.factor(Competition_trait$idTree)),
       species = as.numeric(as.factor(data_trait$Species)),
       complex = as.numeric(as.factor(data_trait$Genus)),
       speciesincomplex = unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[order(unique(cbind(as.numeric(as.factor(data_trait$Species)), as.numeric(as.factor(data_trait$Genus))))[,1]),2],
       data = data_trait,
       competition = Competition_trait,
       sd = c(Trait = sd(unlist(data_trait[trait])), 
              DBH = sd(data_trait$DBH), 
              TWI = sd(data_trait$TWI), 
              DBHj = sd(Competition_trait$DBHj), 
              Deltaj = sd(Competition_trait$dij)))
})
names(mdata) <- traits
```

# Model

We explained leaf trait $Trait$ variation with ontogeny ($DBH$), abiotic environment ($TWI$), biotic interactions ($NCI$) and taxonomic levels ($C, S$ mixed effects, respectivelly fixed and random):

\begin{equation} 
  $$T_{c,s,i} \sim \mathcal{N}(\alpha_{env}.\frac{DBH_i}{{\beta_{DBH}}_{c,s} + DBH_i}, \sigma)    \\
  \alpha_{env} \sim \mathcal{N}(\alpha_{c,s} + {\beta_{TWI}}_{c,s}.TWI_i + {\beta_{Comp}}_{c,s}.\sum_{j=1}^{J} DBH_j^{2} . e^{-{\alpha_{NCI}}_{c,s}.\delta_{i,j}}, \sigma_{env})    \\
  \Theta_{c,s} \sim \mathcal{N}^5(\Theta_c,\sigma_{species}) ~|~ \Theta =
   \begin{bmatrix}
           \alpha \\
           \beta_{DBH} \\
           \beta_{TWI} \\
           \beta_{Comp} \\
           \alpha_{NCI}
  \end{bmatrix},~\sigma_{species}
  \begin{bmatrix}
           \sigma_{Intercept} \\
           \sigma_{DBH} \\
           \sigma_{TWI} \\
           \sigma_{Comp} \\
           \sigma_{NCI}
  \end{bmatrix}  \\
  \Theta_c \sim \mathcal{N}^{5}(0, + \infty) \\
  (\sigma, \sigma_{env}, \sigma_{species}) \sim \Gamma^{7}(- \infty, + \infty)$$
(\#eq:final)
\end{equation}

* $Trait_{c,s,i}$ is a trait of an individual i, from the species s, and the complex c;
* $i \in [1,I_s]$ where $I_s$ is the number of individuals in species s;
* $s \in [1,S_c]$ where $S_c$ is the number of species in complex c;
* $c \in [1,C]$ where $C$ is the number of complexes.
* $i \in [1,I]$ where I is the number of individuals;
* $j \in [1,J_i]$ where $J_i$ is the number of neighbors within the area of diameter $\delta_{max}$ surrounding the individual i, and $DBH_j$ the value of $DBH$ for neighbor $j$;
* $\alpha$ represents both the plateau of the Michaelis Menten and the intercept of each submodel (ontogeny, biotic & abiotic);
* $\beta_{DBH}$  is the value of DBH for which the trait account for half of its saturation value, and thus, ranges in positive values;
* $\beta_{TWI}$ is linear abiotic model parameters. $\beta_{TWI}$ can range in positive or negative value;
* $\beta_{Comp}$ is linear biotic model parameters. $\beta_{Comp}$ can range in positive or negative value;
* $\alpha_{NCI}$ represents the effect of neighbors distance to the individual and will be chosen positive;
* all $\sigma_{species}$ represents parameters variance for species;
* $\sigma$ and $\sigma_{species}$ are standard errors, and thus will have positive values;
* therefore, gamma laws were chosen as non informative flat priors on $\mathbb{R}^+$ for $\sigma$  and $\sigma_{species}$. Normal flat law were chosen as non informative flat prior on $\mathbb{R}$ for all $\Theta_{c,s}$ and $\Theta_c$.

## Code

```{stan stanModel, output.var="Model", echo=T, eval=F}
data {
  int<lower=1>  N ; // # of observations
  int<lower=1>  J ; // # of neighbors
  int<lower=1> S ; // # species
  int<lower=1> C ; // # complex
  vector[N] Trait ; // Trait
  vector[N] DBH ; // Diameter at Breast Height
  vector[N] TWI ; // Topographic Wetness Index
  vector[J] DBHj ; // DBH neighbor
  vector[J] Deltaj ; // Distance neighbor
  vector[N] weights ;
  int<lower=1, upper=N>  individual[J] ; // individuals index in neighbor matrix
  int<lower=1, upper=S> species[N] ; // species index
  int<lower=1, upper=C> speciesincomplex[S] ; // species index wihtin complex
  int<lower=1, upper=C> complex[N] ; // species index
}
transformed data {
  vector[N] Trait_sd ;  // Reducing continuous descriptors
  vector[N] DBH_sd ;
  vector[N] TWI_sd ;
  vector[J] DBHj_sd ;
  vector[J] Deltaj_sd ;
  Trait_sd = Trait ./ sd(Trait) ;
  DBH_sd = DBH ./ sd(DBH) ;
  TWI_sd = TWI ./ sd(TWI) ;
  DBHj_sd = DBHj ./ sd(DBHj) ;
  Deltaj_sd = Deltaj ./ sd(Deltaj) ;
}
parameters {
  vector<lower=0> [C] alpha_sd_c ; // Intercept for complexes
  vector<lower=0> [C] betaDBH_sd_c ; // DBH half-load for complexes
  vector[C] betaTWI_sd_c ; // Abiotic slope for complexes
  vector[C] betaComp_sd_c ; // Biotic slope for complexes
  real<lower=0> alphaNCI_sd ;
  vector<lower=0> [S] alpha_sd_s_tilde ; // Intercept for species
  vector<lower=0> [S] betaDBH_sd_s_tilde ; // DBH half-load for species
  vector[S] betaTWI_sd_s_tilde ; // Abiotic slope for species
  vector[S] betaComp_sd_s_tilde ; // Biotic slope for species
  real<lower=0> sigmaIntercept_sd ; // Intercept variance for species
  real<lower=0> sigmaDBH_sd ; // DBH half-load variance for species
  real<lower=0> sigmaTWI_sd ; // Abiotic slope variance for species
  real<lower=0> sigmaComp_sd ; // Biotic slope variance for species
  real<lower=0> sigma_sd ; // Variance
}
transformed parameters {
  vector<lower=0>[S] alpha_sd_s ; // Non centered random effect
  vector<lower=0> [S] betaDBH_sd_s ;
  vector[S] betaTWI_sd_s ;
  vector[S] betaComp_sd_s ;
  vector[J] NCIj ; // Competition Index
  vector[N] NCI ;
  vector[N] NCI_sd ;
  vector<lower=0> [C]  alpha_c ; // True values of parameters
  vector<lower=0> [C]  betaDBH_c ;
  vector<lower=0> [C]  DBH90 ;
  vector[C] betaTWI_c ;
  vector[C] betaComp_c ;
  real<lower=0> alphaNCI ;
  real<lower=0> sigmaIntercept ;
  real<lower=0> sigmaDBH ;
  real<lower=0> sigmaTWI ;
  real<lower=0> sigmaComp ;
   real<lower=0> sigma ;
  alpha_sd_s = alpha_sd_c[speciesincomplex] + sigmaIntercept_sd*alpha_sd_s_tilde ; // Non centered random effect
  betaDBH_sd_s = betaDBH_sd_c[speciesincomplex] + sigmaDBH_sd*betaDBH_sd_s_tilde ;
  betaTWI_sd_s = betaTWI_sd_c[speciesincomplex] + sigmaTWI_sd*betaTWI_sd_s_tilde ;
  betaComp_sd_s = betaComp_sd_c[speciesincomplex] + sigmaComp_sd*betaComp_sd_s_tilde ;
  NCIj = DBHj_sd .* DBHj_sd .* exp(-alphaNCI_sd * Deltaj_sd) ; // Competition Index
  NCI = rep_vector(0.0, N) ;
  for(j in 1:J)
   NCI[individual[j]] += NCIj[j] ;
  NCI_sd = NCI ./ sd(NCI) ;
  alpha_c = sd(Trait) * alpha_sd_c ; // True values of parameters
  betaDBH_c = sd(DBH) * betaDBH_sd_c ;
  DBH90 = 9 * betaDBH_c ;
  betaTWI_c = sd(TWI) * betaTWI_sd_c ;
  betaComp_c = sd(NCI) * betaComp_sd_c ;
  alphaNCI = sd(Deltaj_sd) * alphaNCI_sd ;
  sigmaIntercept = sd(Trait) * sigmaIntercept_sd ;
  sigmaDBH = sd(DBH) * sigmaDBH_sd ;
  sigmaTWI = sd(TWI) * sigmaTWI_sd ;
  sigmaComp = sd(NCI) * sigmaComp_sd ;
  sigma = sd(Trait) * sigma_sd ;
}
model {
  alpha_sd_c ~ lognormal(0,1) ;
  betaDBH_sd_c ~ lognormal(0,1) ;
  betaTWI_sd_c ~ normal(0, 10^6) ;
  betaComp_sd_c ~ normal(0, 10^6) ;
  alphaNCI_sd ~ lognormal(0, 1) ;
  alpha_sd_s_tilde ~ normal(0, 1) ;
  betaDBH_sd_s_tilde ~ normal(0, 1) ;
  betaTWI_sd_s_tilde ~ normal(0, 1) ;
  betaComp_sd_s_tilde ~ normal(0, 1) ;
  sigmaIntercept_sd ~ lognormal(0, 1) ;
  sigmaDBH_sd ~ lognormal(0, 1) ;
  sigmaTWI_sd ~ lognormal(0, 1) ;
  sigmaComp_sd ~ lognormal(0, 1) ;
  sigma_sd ~ cauchy(0, 5) ;
  Trait_sd ~ normal((alpha_sd_s[species] + betaTWI_sd_s[species] .* TWI_sd +  betaComp_sd_s[species] .* (1 ./ weights) .* NCI_sd) .* (DBH_sd ./ (betaDBH_sd_s[species] + DBH_sd)), sigma_sd) ; // Likelihood
} 
generated quantities {
  vector[N] Trait_pred ;
  vector[N] Trait_predDBH ;
  vector[N] Trait_predTWI ;
  vector[N] Trait_predNCI ;
  Trait_pred = (alpha_c[complex] + betaTWI_c[complex] .* TWI + betaComp_c[complex] .* (1 ./ weights) .* NCI) .* (DBH ./ (betaDBH_c[complex] + DBH));
  Trait_predDBH = (alpha_c[complex] + betaTWI_c[complex] * mean(TWI) + betaComp_c[complex] * mean((1 ./ weights) .* NCI)) .* (DBH ./ (betaDBH_c[complex] + DBH)) ;
  Trait_predTWI = (alpha_c[complex] + + betaTWI_c[complex] .* TWI + betaComp_c[complex] * mean((1 ./ weights) .* NCI)) .* (mean(DBH) ./ (betaDBH_c[complex] + mean(DBH))) ;
  Trait_predNCI = (alpha_c[complex] + betaTWI_c[complex] * mean(TWI) + betaComp_c[complex] .* (1 ./ weights) .* NCI) .* (mean(DBH) ./ (betaDBH_c[complex] + mean(DBH))) ;
}

```

## Summary

```{r fits}
# fits <- lapply(mdata, function(x)
#   sampling(Model, chains = 2, data = x, save_warmup = F,
#            include = F, pars = c('NCIj', "alpha_s", "betaDBH_s", "betaTWI_s",
#                                  "betaComp_s", "alpha_s_tilde",
#                                  "betaDBH_s_tilde", "betaTWI_s_tilde", "betaComp_s_tilde")))
# names(fits) <- traits
# save(fits, file = "./functional_save/Interaction.Rdata")
load("./functional_save/Interaction.Rdata")
pars <- c("alpha", "betaDBH", "betaTWI", "betaComp", "alphaNCI",
          "sigmaIntercept", "sigmaDBH", "sigmaTWI", "sigmaComp", "sigma")
```

```{r summary1, eval=F}
lapply(fits, function(fit)
  broom::tidyMCMC(fit, pars = pars, droppars = NULL, rhat = T)) %>%
  bind_rows(.id = "trait") %>% 
  mutate(complex = gsub("([[:alpha:]])", "", term)) %>% 
  select(trait, term, complex, estimate, std.error, rhat) %>% 
  mutate(complex = gsub("([[:punct:]])", "", complex)) %>% 
  mutate(complex = recode_factor(complex, `2` = "Symphonia", 
                                 `1` = "Eschweilera")) %>% 
  mutate(term = gsub("([[:digit:]])", "", term)) %>% 
  mutate(term = gsub("([[:punct:]])", "", term)) %>% 
  mutate(term = as.factor(gsub("c", "", term))) %>% 
  mutate(term = recode_factor(term, 
                              alpha = "$\\alpha$",
                              betaDBH = "$\\beta_{DBH}$", 
                              betaTWI = "$\\beta_{TWI}$", 
                              betaComp = "$\\beta_{Comps}$", 
                              alphaNCI = "$\\alpha_{NCI}$",
                              sigmaInterept = "$\\sigma^2_{Intercept}$",
                              sigmaDBH = "$\\sigma^2_{DBH}$", 
                              sigmaTWI = "$\\sigma^2_{TWI}$",
                              sigmaComp = "$\\sigma^2_{Comp}$",
                              sigma = "$\\sigma^2$")) %>% 
  mutate(trait = recode_factor(trait, 
                              invSLA = "$\\frac{1}{SLA}$",
                              LDMC = "$LDMC$", 
                              LT = "$LT$", 
                              invLA = "$\\frac{1}{LA}$",
                              CC = "$CC$")) %>% 
  kable(caption = "Model parameters posterior.",
        escape = F, col.names = c("Trait", "Parameter", "Complex",
                                  "Estimate", "Standard Error", "$\\hat R$")) %>% 
  kable_styling(full_width = F) %>% 
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1:2)
```

```{r summary2}
lapply(fits, function(fit)
  broom::tidyMCMC(fit, pars = pars, droppars = NULL, rhat = T)) %>%
  bind_rows(.id = "trait") %>% 
  mutate(complex = gsub("([[:alpha:]])", "", term)) %>% 
  select(trait, term, complex, estimate, std.error, rhat) %>% 
  mutate(complex = gsub("([[:punct:]])", "", complex)) %>% 
  mutate(complex = recode_factor(complex, `2` = "Symphonia", 
                                 `1` = "Eschweilera")) %>% 
  mutate(term = gsub("([[:digit:]])", "", term)) %>% 
  mutate(term = gsub("([[:punct:]])", "", term)) %>% 
  mutate(term = as.factor(gsub("c", "", term))) %>% 
  mutate(term = recode_factor(term, 
                              alpha = "$\\alpha$",
                              betaDBH = "$\\beta_{DBH}$", 
                              betaTWI = "$\\beta_{TWI}$", 
                              betaComp = "$\\beta_{Comps}$", 
                              alphaNCI = "$\\alpha_{NCI}$",
                              sigmaInterept = "$\\sigma^2_{Intercept}$",
                              sigmaDBH = "$\\sigma^2_{DBH}$", 
                              sigmaTWI = "$\\sigma^2_{TWI}$",
                              sigmaComp = "$\\sigma^2_{Comp}$",
                              sigma = "$\\sigma^2$")) %>% 
  mutate(trait = recode_factor(trait, 
                              invSLA = "$\\frac{1}{SLA}$",
                              LDMC = "$LDMC$", 
                              LT = "$LT$", 
                              invLA = "$\\frac{1}{LA}$",
                              CC = "$CC$")) %>% 
  reshape2::dcast(term + complex ~ trait, value.var = "estimate") %>% 
  rename(Parameter = term, Complex = complex) %>% 
  kable(caption = "Model parameters posterior.",
        escape = F) %>% 
  kable_styling(full_width = F) %>% 
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1:2)
```

## Diagnostic

```{r diagnostic, fig.cap="Markov chains trace plot after warmup for SLA model."}
# lapply(fits, check_divergences)
mcmc_trace(as.array(fits$LT, pars = c(pars, "lp__")),
             facet_args = list(labeller = label_parsed))
# mcmc_pairs(as.array(fits$invSLA), regex_pars = pars)
```

```{r lp, fig.cap="Model likelihood."}
lapply(fits, function(fit) 
  mcmc_intervals_data(as.array(fit,
                      pars = c("lp__")))) %>% 
  bind_rows(.id = "trait") %>% 
  mutate(parameter = recode_factor(parameter, lp__ = "log-likelihood")) %>% 
  ggplot(aes(x = trait, xend = trait)) +
  geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
  geom_segment(aes(y = ll, yend = hh),
               size = 1, show.legend = F, alpha = 0.5) +
  geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
  coord_flip() +
  facet_wrap(~ parameter, labeller = label_parsed, scales = "free") +
  xaxis_title(F) +
  yaxis_title(F)
```

## Posteriors

```{r posteriorsSigma, fig.cap="Model variance (for standardized traits)."}
lapply(fits, function(fit) 
  mcmc_intervals_data(as.array(fit,
                      pars = c("sigma")))) %>% 
  bind_rows(.id = "trait") %>% 
  mutate(parameter = recode_factor(parameter, sigma_sd = "sigma^2")) %>% 
  ggplot(aes(x = trait, xend = trait)) +
  geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
  geom_segment(aes(y = ll, yend = hh),
               size = 1, show.legend = F, alpha = 0.5) +
  geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
  coord_flip() +
  facet_wrap(~ parameter, labeller = label_parsed, scales = "free") +
  xaxis_title(F) +
  yaxis_title(F)
```

```{r posteriorIntercept, fig.cap="Model intercept (for standardized traits)."}
lapply(fits, function(fit) 
  mcmc_intervals_data(as.array(fit,
                               pars = c("alpha",
                                        "sigmaIntercept")))) %>% 
  bind_rows(.id = "trait") %>% 
  mutate(complex = gsub("([[:alpha:]])", "", parameter)) %>% 
  mutate(complex = gsub("([[:punct:]])", "", complex)) %>% 
  mutate(complex = ifelse(complex == "", NA, complex)) %>% 
  mutate(complex = recode_factor(complex, `2` = "Symphonia",
                                 `1` = "Eschweilera")) %>% 
  mutate(parameter = gsub("([[:digit:]])", "", parameter)) %>% 
  mutate(parameter = gsub("([[:punct:]])", "", parameter)) %>%
  mutate(parameter = recode_factor(parameter, alphasdc = "alpha",
                                   sigmaIntercept = "sigma[Intercept]^2")) %>%
  ggplot(aes(x = trait, xend = trait, col = complex, fill = complex)) +
  geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
  geom_segment(aes(y = ll, yend = hh),
               size = 1, show.legend = F, alpha = 0.5) +
  geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
  coord_flip() +
  facet_wrap(~ parameter, labeller = label_parsed, scales = "free") +
  xaxis_title(F) +
  yaxis_title(F) +
  scale_color_discrete("Species complex", 
                       labels = c("Symphonia", "Eschweilera", "Both")) +
  scale_fill_discrete("Species complex",
                      labels = c("Symphonia", "Eschweilera", "Both"))
```

```{r posteriorDBH, fig.cap="Model DBH effect."}
lapply(fits, function(fit) 
  mcmc_intervals_data(as.array(fit,
                               pars = c("betaDBH",
                                        "sigmaDBH")))) %>% 
  bind_rows(.id = "trait") %>% 
  mutate(complex = gsub("([[:alpha:]])", "", parameter)) %>% 
  mutate(complex = gsub("([[:punct:]])", "", complex)) %>% 
  mutate(complex = ifelse(complex == "", NA, complex)) %>% 
  mutate(complex = recode_factor(complex, `2` = "Symphonia",
                                 `1` = "Eschweilera")) %>% 
  mutate(parameter = gsub("([[:digit:]])", "", parameter)) %>% 
  mutate(parameter = gsub("([[:punct:]])", "", parameter)) %>%
  mutate(parameter = recode_factor(parameter, betaDBH = "beta[DBH]",
                                   sigmaDBH = "sigma[DBH]^2")) %>%
  mutate(parameter = factor(parameter, levels = c("beta[DBH]", "sigma[DBH]^2"))) %>%
  ggplot(aes(x = trait, xend = trait, col = complex, fill = complex)) +
  geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
  geom_segment(aes(y = ll, yend = hh),
               size = 1, show.legend = F, alpha = 0.5) +
  geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
  coord_flip() +
  facet_wrap(~ parameter, labeller = label_parsed, scales = "free") +
  xaxis_title(F) +
  yaxis_title(F) +
  scale_color_discrete("Species complex",
                       labels = c("Symphonia", "Eschweilera", "Both")) +
  scale_fill_discrete("Species complex",
                      labels = c("Symphonia", "Eschweilera", "Both")) +
  scale_y_log10()
```

```{r posteriorTWI, fig.cap="Model TWI effect (for standardized TWI)."}
S_sqrt_trans <- function() scales::trans_new("S_sqrt",
                                             function(x) sign(x)*sqrt(abs(x)),
                                             function(x) x^2*sign(x))
lapply(fits, function(fit) 
  mcmc_intervals_data(as.array(fit,
                               pars = c("betaTWI",
                                        "sigmaTWI")))) %>% 
  bind_rows(.id = "trait") %>% 
  mutate(complex = gsub("([[:alpha:]])", "", parameter)) %>% 
  mutate(complex = gsub("([[:punct:]])", "", complex)) %>% 
  mutate(complex = ifelse(complex == "", NA, complex)) %>% 
  mutate(complex = recode_factor(complex, `2` = "Symphonia",
                                 `1` = "Eschweilera")) %>% 
  mutate(parameter = gsub("([[:digit:]])", "", parameter)) %>% 
  mutate(parameter = gsub("([[:punct:]])", "", parameter)) %>%
  mutate(parameter = recode_factor(parameter, betaTWI = "beta[TWI]",
                                   sigmaTWI = "sigma[TWI]^2")) %>%
  mutate(parameter = factor(parameter, levels = c("beta[TWI]", "sigma[TWI]^2"))) %>%
  ggplot(aes(x = trait, xend = trait, col = complex, fill = complex)) +
  geom_hline(yintercept = 0, color = "gray90", size = 0.5) +
  geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
  geom_segment(aes(y = ll, yend = hh),
               size = 1, show.legend = F, alpha = 0.5) +
  geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
  coord_flip() +
  facet_wrap(~ parameter, labeller = label_parsed, scales = "free") +
  xaxis_title(F) +
  yaxis_title(F) +
  scale_color_discrete("Species complex",
                       labels = c("Symphonia", "Eschweilera", "Both")) +
  scale_fill_discrete("Species complex",
                      labels = c("Symphonia", "Eschweilera", "Both")) +
  scale_y_continuous(trans="S_sqrt")
```

```{r posteriorTWI2, fig.cap="Model TWI effect (for standardized TWI)."}
S_sqrt_trans <- function() scales::trans_new("S_sqrt",
                                             function(x) sign(x)*sqrt(abs(x)),
                                             function(x) x^2*sign(x))
lapply(fits, function(fit) 
  mcmc_intervals_data(as.array(fit,
                               pars = c("betaTWI",
                                        "betaTWI_s")))) %>% 
  bind_rows(.id = "trait") %>% 
  separate(parameter, c("parameter", "sd", "taxonomy"), sep = "_") %>% 
  select(-sd) %>% 
  mutate(taxonomy = gsub("([[:punct:]])", "", taxonomy)) %>% 
  mutate(species = gsub("([[:alpha:]])", "", taxonomy)) %>% 
  mutate(taxonomy = gsub("([[:digit:]])", "", taxonomy)) %>% 
  mutate(taxonomy = recode_factor(taxonomy, c = "complex", s = "species")) %>% 
  mutate(species = ifelse(taxonomy == "complex",
                        levels(as.factor(Individuals$Genus))[as.numeric(species)],
                        levels(as.factor(Individuals$SpeciesLong))[as.numeric(species)])) %>% 
  mutate(complex = ifelse(substr(species, 1,1) == "E", "Eschweilera", "Symhponia")) %>% 
  ggplot(aes(x = interaction(taxonomy, complex, trait), 
             xend = interaction(taxonomy, complex, trait), 
             color = species, fill = species)) +
  geom_hline(yintercept = 0, color = "gray90", size = 0.5) +
  geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
  geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
  coord_flip() +
  facet_wrap(~ parameter, labeller = label_parsed, scales = "free") +
  xaxis_title(F) +
  yaxis_title(F) +
  scale_y_continuous(trans="S_sqrt")
```

```{r posteriorNCI, fig.cap="Model NCI effect (for standardized NCI)."}
S_sqrt_trans <- function() scales::trans_new("S_sqrt",
                                             function(x) sign(x)*sqrt(abs(x)),
                                             function(x) x^2*sign(x))
lapply(fits, function(fit) 
  mcmc_intervals_data(as.array(fit),
                      regex_pars = c("betaComp_sd_c",
                                     "sigmaComp_sd"))) %>% 
  bind_rows(.id = "trait") %>% 
  mutate(complex = gsub("([[:alpha:]])", "", parameter)) %>% 
  mutate(complex = gsub("([[:punct:]])", "", complex)) %>% 
  mutate(complex = ifelse(complex == "", NA, complex)) %>% 
  mutate(complex = recode_factor(complex, `2` = "Symphonia",
                                 `1` = "Eschweilera")) %>% 
  mutate(parameter = gsub("([[:digit:]])", "", parameter)) %>% 
  mutate(parameter = gsub("([[:punct:]])", "", parameter)) %>%
  mutate(parameter = recode_factor(parameter, betaCompsdc = "beta[Comp]",
                                   sigmaCompsd = "sigma[Comp]^2")) %>%
  mutate(parameter = factor(parameter, levels = c("beta[Comp]", "sigma[Comp]^2"))) %>%
  ggplot(aes(x = trait, xend = trait, col = complex, fill = complex)) +
  geom_hline(yintercept = 0, color = "gray90", size = 0.5) +
  geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
  geom_segment(aes(y = ll, yend = hh),
               size = 1, show.legend = F, alpha = 0.5) +
  geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
  coord_flip() +
  facet_wrap(~ parameter, labeller = label_parsed, scales = "free") +
  xaxis_title(F) +
  yaxis_title(F) +
  scale_color_discrete("Species complex",
                       labels = c("Symphonia", "Eschweilera", "Both")) +
  scale_fill_discrete("Species complex",
                      labels = c("Symphonia", "Eschweilera", "Both")) +
  scale_y_continuous(trans="S_sqrt")
```

```{r posteriorNCI2, fig.cap="Model NCI effect (for standardized NCI)."}
S_sqrt_trans <- function() scales::trans_new("S_sqrt",
                                             function(x) sign(x)*sqrt(abs(x)),
                                             function(x) x^2*sign(x))
lapply(fits, function(fit) 
  mcmc_intervals_data(as.array(fit),
                      regex_pars = c("betaComp_sd_c",
                                     "betaComp_sd_s"))) %>% 
  bind_rows(.id = "trait") %>% 
  separate(parameter, c("parameter", "sd", "taxonomy"), sep = "_") %>% 
  select(-sd) %>% 
  mutate(taxonomy = gsub("([[:punct:]])", "", taxonomy)) %>% 
  mutate(species = gsub("([[:alpha:]])", "", taxonomy)) %>% 
  mutate(taxonomy = gsub("([[:digit:]])", "", taxonomy)) %>% 
  mutate(taxonomy = recode_factor(taxonomy, c = "complex", s = "species")) %>% 
  mutate(species = ifelse(taxonomy == "complex",
                        levels(as.factor(Individuals$Genus))[as.numeric(species)],
                        levels(as.factor(Individuals$SpeciesLong))[as.numeric(species)])) %>% 
  mutate(complex = ifelse(substr(species, 1,1) == "E", "Eschweilera", "Symhponia")) %>% 
  ggplot(aes(x = interaction(taxonomy, complex, trait), 
             xend = interaction(taxonomy, complex, trait), 
             color = species, fill = species)) +
  geom_hline(yintercept = 0, color = "gray90", size = 0.5) +
  geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
  geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
  coord_flip() +
  facet_wrap(~ parameter, labeller = label_parsed, scales = "free") +
  xaxis_title(F) +
  yaxis_title(F) +
  scale_y_continuous(trans="S_sqrt")
```
## Predictions

```{r prediction, fig.cap="Predictions.", fig.width=12, fig.height=12}
lapply(as.list(c("DBH", "TWI", "NCI")), function(variable)
  lapply(as.list(traits), function(trait) {
    if(variable == "NCI") {
      value <- apply(as.matrix(fits[[trait]], pars = "NCI_sd"), 2, mean)
    } else {
      value <- mdata[[trait]][[variable]]
    }
    data.frame(
      trait = trait, 
      variable = variable,
      Y = mdata[[trait]]$Trait,
      value = value,
      Genus = mdata[[trait]]$complex,
      mu = apply(as.matrix(fits[[trait]], pars = paste0("Trait_pred", variable)), 
                 2, mean),
      mu5 = apply(as.matrix(fits[[trait]], pars = paste0("Trait_pred", variable)), 
                  2, quantile, probs = 0.05),
      mu95 = apply(as.matrix(fits[[trait]], pars = paste0("Trait_pred", variable)), 
                   2, quantile, probs = 0.95)
    )
  }) %>% bind_rows()) %>% 
  bind_rows() %>% 
  ggplot(aes(x = value, col = as.factor(Genus))) +
  geom_point(aes(y = Y)) +
  geom_ribbon(aes(ymin = mu5, ymax = mu95), alpha = 0.2) +
  geom_line(aes(y = mu)) +
  facet_grid(trait ~ variable, scales = "free") +
  scale_color_discrete("Complex", labels = c("Eschweilera", "Symphonia"))
```

```{r ppc, eval=F}
cowplot::plot_grid(plotlist = mapply(function(fit, data) 
  ppc_dens_overlay(data$Trait, as.matrix(fit, pars = "Trait_pred")), 
  fit = fits, data = mdata, SIMPLIFY = F), labels = names(fits))
```

# Conclusion

# References
