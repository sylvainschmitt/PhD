---
title: "A02: Joint taxa model"
date: '`r Sys.Date()`'
author: Sylvain Schmitt
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
vertical_layout: scroll
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(tidyverse)
library(kableExtra)
library(rstan)
library(bayesplot)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 6,
  cache = T, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
```

Intro
==================

Issue {data-width=200}
-------------------------------------

The aim of this document is to find the best general form of model to fit a joint distribution model. Especially we are thinking for a model that can deal with three specific cases :

* The environmental variable has no effect
* The niche optimum is in a intermediate value of the environmental variable range
* The niche optimum is at a limit of the environmental variable range

For this we will build three fake data sets distributed along our environmental variable as follow :

Data {data-width=200}
-------------------------------------

#### Fake data

```{r fakeData}
n <- 100
data <- list(
  no = data.frame(Environment = seq(0, 1, length.out = 100),
                  A = c(rep(0:1, 50)),
                  B = c(rep(c(1,0), 50)),
                  C = c(rep(c(1,0), 50))),
  intermediate = data.frame(Environment = seq(0, 1, length.out = n),
                            A = c(rep(0, 20), 
                                  rep(0:1,10),
                                  rep(1,20),
                                  rep(0:1,10),
                                  rep(0,20)),
                            B = c(rep(0, 5), 
                                  rep(0:1,10),
                                  rep(1,20),
                                  rep(0:1,10),
                                  rep(0,35)),
                            C = c(rep(0, 35), 
                                  rep(0:1,10),
                                  rep(1,20),
                                  rep(0:1,10),
                                  rep(0,5))),
  limit = data.frame(Environment = seq(0, 1, length.out = n), 
                     A = c(rep(0,30), rep(0:1,20), rep(1,30)),
                     B = c(rep(0, 20), 
                           rep(0:1,10),
                           rep(1,20),
                           rep(0:1,10),
                           rep(0,20)),
                     C = c(rep(1,30), rep(0:1,20), rep(0,30)))
)
data <- lapply(data, function(x) x %>% 
         reshape2::melt(id.vars = "Environment", 
                        variable.name = "Species", value.name = "Presence") %>% 
         filter(Presence != 0) %>% 
         select(-Presence))
mdata <- lapply(data, function(x) 
  list(S = length(unique(x$Species)),
       N = nrow(x),
       Environment = x$Environment,
       y = sapply(levels(as.factor(x$Species)), 
                  function(sp) as.numeric(x$Species == sp))))
bind_rows(data, .id = "id") %>% 
  ggplot(aes(Environment, fill = Species, col = Species)) + 
  geom_density(alpha = 0.3) +  
  facet_wrap(~id, nrow = 3)
```

$Dirichlet~Multinomial$
==================

Column 1
-------------------------------------

#### Model


$$
Presence_{species} \sim \mathcal{Dirichlet~Multinomial}(softmax(\alpha + \beta*Environment + \gamma*Environment^2)) \\
{Log~Probability~Mass~Function}_{Dirichlet~Multinomial}(y|\alpha) = \Gamma(\sum \alpha)  + \sum(\Gamma(\alpha + y)) - \Gamma(\sum \alpha+\sum y) - \sum\Gamma(\alpha)
$$

#### Code

```{stan , output.var="Model", echo=T, eval=F}
functions {
  real dirichlet_multinomial_lpmf(int[] y, vector alpha) {
    real alpha_plus = sum(alpha);
    return lgamma(alpha_plus) + sum(lgamma(alpha + to_vector(y)))
                - lgamma(alpha_plus+sum(y)) - sum(lgamma(alpha));
  }
}
data {
  int<lower = 1> S  ;
  int<lower = 1> N  ;
  int<lower = 0> y[N, S]  ;
  real Environment[N] ;
}
parameters {
  vector[S] alpha ;
  vector[S] beta ;
  vector[S] gamma ;
}
transformed parameters {
  simplex[S] theta[N] ; 
  for (n in 1:N)
      theta[n] = softmax(alpha + beta*Environment[n] + gamma*Environment[n]*Environment[n]) ;
}
model {
  alpha ~ normal(0,1) ;  
  beta ~ normal(0,1) ;  
  gamma ~ normal(0,1) ;  
  for (n in 1:N)
    y[n] ~ dirichlet_multinomial(theta[n])  ;
}
```

```{r}
# fits <- lapply(mdata, function(x) sampling(Model, chains = 2, data = x))
# names(fits) <- names(mdata)
# save(fits, file = "./distribution_save/Dirichlet.Rdata")
load("./distribution_save/Dirichlet.Rdata")
pars <- c("alpha", "beta", "gamma")
```

#### Chains

```{r , fig.cap="Markov chains trace plot after warmup for intermediate data."}
mcmc_trace(as.array(fits$limit, pars = c(pars, "lp__")),
             facet_args = list(labeller = label_parsed))
```

#### Pairs

```{r , fig.cap="Markov chains pairs plot after warmup  for intermediate data."}
mcmc_pairs(as.array(fits$limit, pars = pars))
```

Column 2
-------------------------------------

#### Predictions

```{r , fig.cap="Predictions."}
lapply(names(mdata), function(type)
  lapply(1:3, function(sp)
    cbind(type = type, data[[type]],
          species = LETTERS[sp],
          Environment = data[[type]]$Environment,
          theta = apply(as.matrix(fits[[type]], 
                                  pars = paste0("theta[", 1:mdata[[type]]$N, ",", sp, "]")), 
                        2, mean),
          theta5 = apply(as.matrix(fits[[type]], 
                                   pars = paste0("theta[", 1:mdata[[type]]$N, ",", sp, "]")), 
                         2, quantile, probs = 0.05),
          theta95 = apply(as.matrix(fits[[type]],
                                    pars = paste0("theta[", 1:mdata[[type]]$N, ",", sp, "]")), 
                          2, quantile, probs = 0.95))) %>% 
  bind_rows()) %>%
  bind_rows() %>% 
  ggplot(aes(x = Environment, col = species)) + 
  geom_ribbon(aes(ymin = theta5, ymax = theta95), alpha = 0.2) +
  geom_line(aes(y = theta)) +
  facet_wrap(~ type, nrow = 3)
```

#### Posteriors

```{r , fig.cap="Model parameters posterior."}
cowplot::plot_grid(plotlist = lapply(names(data), function(type)
  mcmc_intervals(as.array(fits[[type]], pars = pars))),
  labels = names(data), nrow = 2)
```

#### Summary

```{r }
lapply(as.list(names(mdata)), function(type)
  broom::tidyMCMC(fits[[type]], pars = c(pars, "lp__"), droppars = NULL, rhat = T) %>%
    mutate(Type = type)) %>%
  bind_rows() %>%
  kable()
```
