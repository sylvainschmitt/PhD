---
title: "A06: Species distributions"
date: '`r Sys.Date()`'
author: Sylvain Schmitt
output:
  bookdown::html_document2:
    number_sections: false
    toc: true
    toc_float: yes
  bookdown::word_document2: default
  github_document: default
  bookdown::pdf_document2:
    includes:
      before_body: ./template/doc_prefix.tex
      in_header: ./template/preamble.tex
    number_sections: false
    toc: false
linestretch: 1.5
csl: /home/sylvain/Documents/Bibliography/csl/mee.csl
bibliography: /home/sylvain/Documents/Bibliography/library.bib
link-citations: yes
---

```{r setup, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(kableExtra)
library(parallel)
library(tidyverse)
library(ggfortify)
library(raster)
library(leaflet)
library(rstan)
library(bayesplot)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 10, fig.width = 10,
  cache = T, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
path <- "~/Documents/BIOGECO/PhD/data/Paracou/"
crs <- '+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0' # global crs definition
```

```{r trees}
d <- 20
trees <- src_sqlite(file.path(path, "trees", "Paracou.sqlite")) %>% 
  tbl("Paracou") %>% 
  filter(CensusYear == 2015) %>%
  filter(Xfield > d, Xfield < 250-d, Yfield > d, Yfield < 250-d) %>% 
  filter(Species != "Indet.") %>% 
  mutate(DBH = CircCorr/pi) %>% 
  collect()
```

```{r env}
# env <- trees %>%
#   dplyr::select(idTree, Xutm, Yutm) %>%
#   unique()
# coordinates(env) <- ~Xutm + Yutm
# proj4string(env) <- '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
# env <- spTransform(env, CRSobj = crs)
# topo <- stack(
#   raster(file.path(path, "topography", "DEM_1m_2015.tif")),
#   raster(file.path(path, "topography", "RelativeElevation_1m.tif")),
#   raster(file.path(path, "topography", "slope_1m.tif")),
#   raster(file.path(path, "topography", "curvature_1m.tif")),
#   raster(file.path(path, "topography", "TRI_1m.tif")),
#   raster(file.path(path, "topography", "TWI_1m.tif"))
# )
# names(topo) <- c("DEM", "RelativeElevation", "Slope", "Curvature", "TRI", "TWI")
# topo <- projectRaster(topo, crs = crs)
# env <- data.frame(cbind(env@data, raster::extract(topo, env)))
# rm(topo)
# save(env, file = "./distribution_save/env.Rdata")
load("./distribution_save/env.Rdata")
```

```{r Competition}
# cl <- makeCluster(4)
# clusterExport(cl, list("data", "path"))
# Competition <- clusterMap(cl,
#   function(id, plot, census, x, y, genus){
#   library(dplyr)
#   src_sqlite(file.path(path, "trees/Paracou.sqlite")) %>%
#     tbl("Paracou") %>%
#     filter(CensusYear == census) %>%
#     filter(Plot == plot) %>%
#     filter(idTree != id) %>%
#     mutate(DBH = CircCorr/pi) %>%
#     filter(DBH >= 10) %>% # != INRA plots
#     mutate(dij = sqrt((x - Xutm)^2+(y - Yutm)^2)) %>%
#     filter(dij < 10) %>%
#     summarise(BA = sum(0.25*pi*DBH^2),
#               BAgenus =  sum(0.25*pi*DBH^2*as.numeric(Genus == genus))) %>%
#     mutate(idTree = id) %>%
#     dplyr::select(idTree, BA, BAgenus) %>%
#     collect()},
#   id = trees$idTree,
#   plot = trees$Plot,
#   x = trees$Xutm,
#   y = trees$Yutm,
#   census = trees$CensusYear,
#   genus = trees$Genus,
#   SIMPLIFY = F)
# stopCluster(cl)
# rm(cl)
# Competition <- bind_rows(Competition)
# save(Competition, file = "./distribution_save/Competition.Rdata")
load("./distribution_save/Competition.Rdata")
Competition <- Competition %>% 
  mutate(dij = ifelse(dij <1, 1, dij)) %>% 
  left_join(dplyr::select(trees, idTree, Genus, Species)) %>% 
  mutate(strata = as.numeric(Genusj == Genus, Speciesj == Species)) %>% 
  group_by(idTree) %>% 
  summarise(NCIother = sum(DBHj^2*exp(-0.25*dij)*abs(strata-1)),
            NCIspecies = sum(DBHj^2*exp(-0.25*dij)*strata))
```

```{r complexes}
Complexes <- bind_rows(
  data.frame(Complex = "E. Chartacea", Genus = "Eschweilera",
             Species = c("simiorum", "congestiflora")),
  data.frame(Complex = "E. Parvifolia", Genus = "Eschweilera",
             Species = c("pedicellata", "coriacea", "decolorans", "sagotiana",
                         "wachenheimii", "grandiflora_form2")),
  data.frame(Complex = "Licania", Genus = "Licania",
             Species = c("alba", "membranacea", "canescens", "micrantha",
                         "ovalifolia", "sprucei", "densiflora",
                         "laxiflora", "parvifructa")),
  data.frame(Complex = "Iryanthera", Genus = "Iryanthera",
             Species = c("hostmannii", "sagotiana")),
  data.frame(Complex = "Talisia", Genus = "Talisia",
             Species = c("hexaphylla", "praealta", "simaboides")),
  data.frame(Complex = "Symphonia", Genus = "Symphonia",
             Species = c("globulifera", "sp.1")))
```

```{r data}
data <- trees %>% 
  left_join(env) %>% 
  left_join(Complexes) %>% 
  left_join(Competition) %>% 
  filter(!is.na(Plot)) %>% 
  filter(!is.na(Complex)) %>% 
  group_by(Complex, Species) %>% 
  filter(n() > 10) %>% 
  ungroup()
data <- data %>% group_by(Complex) %>% sample_n(200) %>% ungroup()
```

```{r mdata}
complexes <- unique(Complexes$Complex)
mdata <- lapply(complexes, function(complex) {
  data<- filter(data, Complex == complex)
  list(N = nrow(data),
       S = length(unique(data$Species)),
       K = 3,
       Y = sapply(levels(as.factor(data$Species)),
                  function(sp) as.numeric(data$Species == sp)),
       X = dplyr::select(data, TWI, NCIother, NCIspecies) %>%
         mutate_all(funs(scale)) %>%
         as.matrix())
})
names(mdata) <- complexes
```

```{r fit}
# Model <- stan_model("A02-JointModel.stan")
# fits <- lapply(mdata, function(data) sampling(Model, chains = 2, data = data))
# names(fits) <- complexes
# save(fits, file = "./distribution_save/species.Rdata")
load("./distribution_save/species.Rdata")
pars <- c("alpha", "beta", "gamma")
species <- lapply(mdata, function(data) 
  data.frame(species = 1:length(colnames(data$Y)),
             Species = colnames(data$Y))
  ) %>% bind_rows(.id = "complex") %>% 
  mutate(SpeciesLong = paste(substr(complex, 1, 1), Species))
```

# Introduction

The aim of this document is to study the distribution at micro-environmental scale with biotic and abiotic environment of species within species complexes in Paracou (not the whole species complex).

# Material and Methods

## Study site

Paracou

## Individuals

Studied complexes remain to be defined in document [A04-Complexes](A04-Complexes.html), 

* *E. charatcaea*
* *E. Parvifolia*
* *Licania*
* *Iryanthera*
* *Talisia*
* *Symphonia*

## Environmental variables

To be defined in document [A03-Descriptors](A03-Descriptors.html),

* TWI
* BA
* BAgenus
* BAspecies

## Analysis

We analysed species distribution within species complex by comparing to which species belonged occurrences of the species complex. Species distribution within species complex has been investigating through softmax regression following a conjugated Dirchlet and Multinomial distribution (see document [A02-JointModel](A01-JointModel.html)):

$$Presence_{species} \sim \mathcal{Dirichlet~Multinomial}(softmax(\alpha + \beta*X + \gamma*X^2))$$
$${Log~Probability~Mass~Function}_{Dirichlet~Multinomial}(y|\alpha) = \Gamma(\sum \alpha)  + \sum(\Gamma(\alpha + y)) - \Gamma(\sum \alpha+\sum y) - \sum\Gamma(\alpha)$$
with $X$ the matrix of environmental descriptors of size $[N,K]$, $\alpha$ the intercept, $\beta$ a vector of size $K$ representing the slope and $\gamma$ a vector of size $K$ representing the quadratic form.

Environmental descriptors were all scaled for the model inference, in order to ease model inference and later compare strength of effects between traits and between effects. A Bayesian method was used to infer parameters of the model regarding each leaf traits using `stan` language [ref] and `rstan` package [ref] in the R environment [ref] (see supplementary material [S1: Model] for model equations and `stan` code).

<!-- ### Overlap test -->

<!-- `dismo::nicheOverlap`  functions as other compute niche overlap from distribution projected on rasters which miss the overlap computation of the theoritical niche in the full environmental space tested. We will build an overlap index as the intersection of habitat suitability distribution (product of distribution functions) divided by the total sum of habitat suitability distribution (sum of distribution functions) : -->

<!-- $$I_{overlap} = \frac{\cap niche}{\sum niche} = \frac{\prod_sdistribution_s}{\sum_sdistribution_s} =  \frac{\prod_s f_s(DEM, TWI, Slope)}{\sum_s f_s(DEM, TWI, Slope)}$$ -->

# Results

The model inference correctly converged without divergent transition and resulted in a correct predictions density distribution (see supplementary material [S2: Diagnostic]).

Table \@ref(tab:summary) and figures \@ref(fig:posterior) and \@ref(fig:prediciton) will not be commented yet as they represent preliminary results.

Still we can note globally that inside each complex the abiotic environment represented by TWI seems to affect oppositely niche distribution of species and that they are ranked in their response. Species distributions within complex are also more or less shaped by congeneric interactions represented by BAgenus. *E. Chartacea*, *Symphonia* and *Iryanthera* have similarly a strong differentiation of habitat with water accumulation between more abundant species. This signal is found at a smaller level in *Licania* but with *L. alba* staying dominant all along. Consequently, *S. globulifera* and *S. sp1*, *I. hostmanii* and *I. sagotiana*, and *E. sagotiana* and *E. coriacea* show a very small overlap of ecological niches. Last but not least, whereas *E. pedicellata* genetically closer to *E. coriacea* seems to share a similar niche, and *E. decolorans* seems to show an optimum of TWI when sister species only increase or decrease their habitat suitability with TWI.

**Beware that those quick interpretation have to be confirmed after the final analysis !**

```{r summary}
lapply(fits, function(fit)
  broom::tidyMCMC(fit, pars = c(pars), droppars = NULL, rhat = T)) %>%
  bind_rows(.id = "complex") %>% 
  mutate(index = gsub("([[:alpha:]])", "", term)) %>% 
  mutate(index = gsub("([[:punct:]])", "", index)) %>% 
  mutate(term = gsub("([[:digit:]])", "", term)) %>% 
  mutate(term = gsub("([[:punct:]])", "", term)) %>% 
  mutate(species = as.numeric(substr(index, 1, 1))) %>% 
  left_join(species) %>% 
  mutate(descriptor = substr(index, 2, 2)) %>% 
  dplyr::select(complex, term, SpeciesLong, descriptor, estimate) %>% 
  mutate(descriptor = recode_factor(descriptor, `1` = "TWI", 
                                    `2` = "NCIother", `3` = "NCIspecies")) %>% 
  mutate(term = recode_factor(term, alpha = "$\\alpha$", 
                              beta = "$\\beta$", 
                              gamma = "$\\gamma$")) %>%
  reshape2::dcast(term + descriptor ~ SpeciesLong, value.var = "estimate") %>%
  kable(caption = "Model parameters for each complex with scaled descriptors.",
        escape = F, digits = 3, format = "pandoc") %>% 
  kable_styling(full_width = F) %>% 
  column_spec(1, bold = T) %>%
  collapse_rows(columns = 1:3)
```

```{r posterior, fig.cap="Model parameters posterior.", fig.width=10, fig.height=14}
lapply(complexes, function(complex) 
  mcmc_intervals_data(as.array(fits[[complex]], pars = pars)) %>% 
    mutate(complex = complex) %>% 
    mutate(descriptor = gsub("([[:alpha:]])", "", parameter)) %>% 
    mutate(descriptor = gsub("([[:punct:]])", "", descriptor)) %>% 
    mutate(parameter = gsub("([[:digit:]])", "", parameter)) %>% 
    mutate(parameter = gsub("([[:punct:]])", "", parameter)) %>% 
    mutate(species = as.numeric(substr(descriptor, 1, 1))) %>% 
    left_join(species) %>% 
    mutate(descriptor = substr(descriptor, 2, 2)) %>% 
    mutate(descriptor = recode_factor(descriptor, `1` = "TWI", 
                                      `2` = "NCIother", `3` = "NCIspecies")) %>% 
    dplyr::select(complex, parameter, descriptor, SpeciesLong, ll, l, m, h, hh) %>% 
    filter(parameter != "alpha") %>% 
    mutate(parameter = paste0(parameter, "[", descriptor, "]")) %>% 
    ggplot(aes(x = datatools::reorder_within(SpeciesLong, m, parameter),
               xend = datatools::reorder_within(SpeciesLong, m, parameter), 
               col = SpeciesLong, fill = SpeciesLong)) +
    geom_hline(yintercept = 0, color = "gray90", size = 0.5) +
    geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
    geom_segment(aes(y = ll, yend = hh),
                 size = 1, show.legend = F, alpha = 0.5) +
    geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
    coord_flip() +
    facet_wrap(~ parameter, labeller = label_parsed, 
               scales = "free") +
    datatools::scale_x_reordered() +
    xlab("") + ylab("") + 
    scale_fill_discrete(guide = "none") +
    scale_color_discrete(guide = "none") +
    ggtitle(complex)) %>% 
  gridExtra::grid.arrange(grobs = .)
```

```{r prediciton, fig.cap="Predictions."}
preds <- lapply(complexes, function(complex){

  N <- 25
  TWI <- seq(from = min(mdata[[complex]]$X[,1]), 
             to = max(mdata[[complex]]$X[,1]), length.out = N)
  BA <- seq(from = min(mdata[[complex]]$X[,2]), 
             to = max(mdata[[complex]]$X[,2]), length.out = N)
  BAgenus <- seq(from = min(mdata[[complex]]$X[,3]), 
             to = max(mdata[[complex]]$X[,3]), length.out = N)
  
  S <- mdata[[complex]]$S
  K <- mdata[[complex]]$K
  alpha <- as.matrix(fits[[complex]], pars = "alpha")
  beta0 <- as.matrix(fits[[complex]], pars = "beta")
  gamma0 <- as.matrix(fits[[complex]], pars = "gamma")
  beta <- array(dim = c(nrow(alpha), S, K))
  gamma <- array(dim = c(nrow(alpha), S, K))
  for(k in 1:K){
    beta[,,k] <- beta0[,seq.int(1, 3*S, S)[k]:(seq.int(1, 3*S, S)+(S-1))[k]]
    gamma[,,k] <- gamma0[,seq.int(1, 3*S, S)[k]:(seq.int(1, 3*S, S)+(S-1))[k]]
  }
    
  Yp <- abind::abind(sapply(1:length(TWI), function(i) 
    sapply(1: nrow(alpha), function(n)
      tsensembler:::softmax(alpha[n,] + beta[n,,1] * TWI[i] + beta[n,,2]*BA[i] + beta[n,,3]*BAgenus[i] + gamma[n,,1]*TWI[i]^2 + gamma[n,,2]*BA[i]^2 + gamma[n,,3]*BAgenus[i]^2)
    ), simplify = F), along = 3)
  Ytwi <- abind::abind(sapply(1:length(TWI), function(i) 
    sapply(1: nrow(alpha), function(n)
      tsensembler:::softmax(alpha[n,] + beta[n,,1]*TWI[i] + beta[n,,2]*mean(BA) + beta[n,,3]*mean(BAgenus) + gamma[n,,1]*TWI[i]^2 + gamma[n,,2]*mean(BA)^2 + gamma[n,,3]*mean(BAgenus)^2)
    ), simplify = F), along = 3)
  Ybagenus <- abind::abind(sapply(1:length(TWI), function(i) 
    sapply(1: nrow(alpha), function(n)
      tsensembler:::softmax(alpha[n,] + beta[n,,1]*mean(TWI) + beta[n,,2]*mean(BA) + beta[n,,3]*BAgenus[i] + gamma[n,,1]*mean(TWI)^2 + gamma[n,,2]*mean(BA)^2 + gamma[n,,3]*BAgenus[i]^2)
    ), simplify = F), along = 3)

  bind_rows(
    lapply(1:S, function(sp)
      data.frame(
        complex = complex,
        species = colnames(mdata[[complex]]$Y)[sp],
        variable = "TWI",
        value = TWI,
        Y = apply(Ytwi[sp,,], 2, mean),
        Y5 = apply(Ytwi[sp,,], 2, quantile, probs = 0.05),
        Y95 = apply(Ytwi[sp,,], 2, quantile, probs = 0.95))) %>% 
      bind_rows(),
    lapply(1:S, function(sp)
      data.frame(
        complex = complex,
        species = colnames(mdata[[complex]]$Y)[sp],
        variable = "BAgenus",
        value = BAgenus,
        Y = apply(Ybagenus[sp,,], 2, mean),
        Y5 = apply(Ybagenus[sp,,], 2, quantile, probs = 0.05),
        Y95 = apply(Ybagenus[sp,,], 2, quantile, probs = 0.95))) %>% 
      bind_rows())
}) %>% bind_rows()
preds %>% 
  group_by(complex) %>% 
  do(g = ggplot(data = ., aes(x = value, col = species)) + 
       geom_ribbon(aes(ymin = Y5, ymax = Y95), alpha = 0.2) +
       geom_line(aes(y = Y)) +
       facet_grid(complex ~ variable, scales = "free_x") +
       guides(col = guide_legend(nrow=2)) +
       theme(legend.position = "bottom") +
       scale_y_sqrt()) %>% 
  gridExtra::grid.arrange(grobs = .$g)
```

# Discussion

# Supplementray materials

## S1: Model

```{stan Model, output.var="Model", echo=T, eval=F}
functions {
  real dirichlet_multinomial_lpmf(int[] y, vector alpha) {
    real alpha_plus = sum(alpha);
    return lgamma(alpha_plus) + sum(lgamma(alpha + to_vector(y)))
                - lgamma(alpha_plus+sum(y)) - sum(lgamma(alpha));
  }
}
data {
  int<lower = 1> N  ;       // # of individuals
  int<lower = 1> S  ;       // # of species
  int<lower = 0, upper=1> Y[N, S]  ; // individuals presence or absence for each species
  vector[N] TWI ; // Topographical Wetness Index
  vector[N] BA ; // Basal Area
  vector[N] BAgenus ; // Congeneric Basla Area
  vector<lower=0, upper=1>[N] w ; // weights for pseudo-absence to be equal to presence
}
parameters {
  vector[S] alpha ; // intercept
  matrix[S,3] beta ; // sigmoidal slope
  matrix[S,3] gamma ; // quadratic form
}
model {
  alpha ~ normal(0,1) ;  
  for(k in 1:3){
    beta[,k] ~ normal(0,1) ;
    gamma[,k] ~ normal(0,1) ;
  }
  for (n in 1:N)
    Y[n] ~ dirichlet_multinomial(softmax(alpha + TWI[n] * beta[,1] + TWI[n] * TWI[n] * gamma[,1] + BA[n] * beta[,2] + BA[n] .* BA[n] * gamma[,2] + BAgenus[n] * beta[,3] + BAgenus[n] .* BAgenus[n] * gamma[,3])) ; // likelihood
}
```


## S2: Diagnostic

Model inference converged ($\hat R = 1$, figure \@ref(fig:mcmc)) for every complex with relatively little or no divergent transition (< 0.1%), and relatively uncorrelated parameters.

```{r mcmc, fig.cap="Markov chains trace plot after warmup for leaf thickness model."}
# lapply(fits, check_divergences)
mcmc_trace(as.array(fits$Symphonia, pars = c(pars, "lp__")),
             facet_args = list(labeller = label_parsed))
# mcmc_pairs(as.array(fits$invSLA), regex_pars = pars)
```

## S3: Posterirors

All posteriors.

```{r posteriorAll, fig.cap="Model all parameters posterior."} 
lapply(fits, function(fit) 
  mcmc_intervals_data(as.array(fit, pars = pars))) %>% 
  bind_rows(.id = "complex") %>% 
  mutate(descriptor = gsub("([[:alpha:]])", "", parameter)) %>% 
  mutate(descriptor = gsub("([[:punct:]])", "", descriptor)) %>% 
  mutate(parameter = gsub("([[:digit:]])", "", parameter)) %>% 
  mutate(parameter = gsub("([[:punct:]])", "", parameter)) %>% 
  mutate(species = as.numeric(substr(descriptor, 1, 1))) %>% 
  left_join(species) %>% 
  mutate(descriptor = substr(descriptor, 2, 2)) %>% 
  mutate(descriptor = recode_factor(descriptor, `1` = "TWI", 
                                    `2` = "BA", `3` = "BAgenus")) %>% 
  dplyr::select(complex, parameter, descriptor, SpeciesLong, ll, l, m, h, hh) %>% 
  filter(parameter != "alpha") %>% 
  ggplot(aes(x = SpeciesLong, xend = SpeciesLong, 
             col = SpeciesLong, fill = SpeciesLong)) +
  geom_hline(yintercept = 0, color = "gray90", size = 0.5) +
  geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
  geom_segment(aes(y = ll, yend = hh),
               size = 1, show.legend = F, alpha = 0.5) +
  geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
  coord_flip() +
  facet_grid(descriptor ~ parameter, labeller = label_parsed, scales = "free") +
  xlab("") + ylab("") + 
  scale_fill_discrete(guide = "none") +
  scale_color_discrete(guide = "none")
```

# References
