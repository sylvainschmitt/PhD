```{r setupMethods, include = FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(tidyverse)
library(rstan)
library(bayesplot)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
  cache = T, cache.lazy = F)
path <- "../../../data/CLONAPIN/"
```

# Methods

## Animal model

### Normal data

Let's consider a set of $P=2$ populations including each $Fam=3$ families composed of $I = 14$ individuals with arbitrar relationships. Population, genotypic, and residual variation are defined by $\sigma_P^2$, $\sigma_G^2$ and $\sigma_R^2$, respectivelly. Genotypic noise followed a standard normal and is defined by $\epsilon_G$. And population intercepts are defined by $\mu_P$ following a normal distribution of variance $\sigma_P^2$ centered on 0.

```{r simnormal, fig.cap="Kinship matrix", echo = T}
P <- 2 # Populations
Fam <- 3 # Families
I <- 14 # Individuals
ped.df <- data.frame(pop = rep(1:P, each = Fam*I),
           fam = rep(1:Fam, each = I),
           ind = rep(1:I, Fam*P),
           father = rep(c(NA, NA, 1, 1, 1, 1, NA, 6, 6, 6, NA, 11, 11, 11), Fam*P),
           mother = rep(c(NA, NA, 2, 2, 2, 2, NA, 7, 7, 7, NA, 3, 3, 3), Fam*P), 
           sex = rep(c(1, 2, 2, 3, 3, 1, 2, 3, 3, 3, 1, 3, 3, 3), Fam*P)) %>% 
  mutate_at(c("father", "mother"), funs(ifelse(!is.na(.), paste0(pop,fam,.), NA))) %>%
  mutate(ind = paste0(pop,fam,ind))
ped.ped <- kinship2::pedigree(id = ped.df$ind, dadid = ped.df$father, 
                              momid = ped.df$mother, sex = ped.df$sex, 
                              famid = paste0(ped.df$pop, ped.df$fam))
K <- as.matrix(kinship2::kinship(ped.ped))
K <- 2*K
N <- nrow(K)
sigmaP <- 0.5
sigmaG <- 0.3
sigmaR <- 0.2
epsilonG <- rnorm(N)
muP <- rnorm(P, sd = sigmaP)
mdata <- list(N = N, K = K, population = ped.df$pop,
              ynorm = rnorm(N, muP[ped.df$pop] + 
                              sigmaG*as.vector(t(chol(K)) %*% epsilonG),
                            sigmaR),
              ylognorm = rlnorm(N, 
                                muP[ped.df$pop] + 
                                  sigmaG*as.vector(t(chol(K)) %*% epsilonG),
                                sigmaR))
```

#### Normal distribution 1

The Animal model have the following equation:

$$y \sim \mathcal N(\mu_P + u,\sigma_R)\\u \sim \mathcal{MVN}(0,\sigma_G.K)$$

Than we can rewrite as:

$$y \sim \mathcal N(\mu_P + \sigma_G.A.a,\sigma_R)\\ a \sim \mathcal{N}(0,1)\\|~u =\sigma_G.A.a$$

```{r simnormdistnorm1data, echo = T}
u <- sigmaG*as.vector(t(chol(K)) %*% epsilonG) 
y <- rnorm(N, muP[ped.df$pop] + sigmaG*as.vector(t(chol(K)) %*% epsilonG),
           sigmaR)
ggplot(data.frame(y = y, u = u, pop = as.factor(ped.df$pop)), 
       aes(u, y, col = pop)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  geom_hline(yintercept = muP[ped.df$pop], linetype = "dotted")
```

```{r simnormdistnorm1fit, echo = T}
mNN <- stan_model("variance_models/methods/VarNormDistNorm.stan")
fNN <- sampling(mNN, chains = 2, save_warmup = F, data = mdata,
                control = list(adapt_delta = 0.99, max_treedepth = 12))
broom::tidyMCMC(fNN, ess = T, rhat = T, 
                estimate.method = "median", droppars = F,
                pars = c("mu", "sigma", "lp__"))
mcmc_trace(as.array(fNN, pars = c("mu", "sigma"))) +
   geom_hline(aes(yintercept = expected), col = "red", 
           data = data.frame(parameter = c("mu[1]", "mu[2]", 
                                           "sigma[1]", "sigma[2]"), 
                               expected = c(muP, sigmaR, sigmaG)))
```

#### Normal distribution 2

But the Animal model can be writen with the following equation too:

$$y \sim \mathcal N(u',\sigma_R)\\u' \sim \mathcal{MVN}(\mu_P,\sigma_G.K)\\u'=u+\mu_p$$

Than we can rewrite as:

$$y \sim \mathcal N(\mu_P + \sigma_G.A.a,\sigma_R)\\a \sim \mathcal{N}(0,1)\\|~u' =\mu_P + \sigma_G.A.a\\u=\sigma_G.A.a$$

Once non-centered it's totally the same model as the previous one.

```{r simnormdistnorm2data, echo = T}
up <- muP[ped.df$pop] + sigmaG*as.vector(t(chol(K)) %*% epsilonG) 
u <- up - muP[ped.df$pop]
y <- rnorm(N, 
           muP[ped.df$pop] + sigmaG*as.vector(t(chol(K)) %*% epsilonG),
           sigmaR)
ggplot(data.frame(y = y, u = u, pop = as.factor(ped.df$pop)), 
       aes(u, y, col = pop)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  geom_hline(yintercept = muP[ped.df$pop], linetype = "dotted")
```

#### Lognormal distribution 1

And if we know use a lognormal distribution

$$e^y \sim \mathcal {logN}(u',\sigma_R)\\u' \sim \mathcal{MVN}(\mu_P,\sigma_G.K)\\u'=u+\mu_p$$

Than we can rewrite as:

$$e^y \sim \mathcal {logN}(\mu_P + \sigma_G.A.a,\sigma_R)\\a \sim \mathcal{N}(0,1)\\|~u' = \mu_P + \sigma_G.A.a\\u= \sigma_G.A.a$$

```{r simnormdistlognorm1data, echo = T}
up <- muP[ped.df$pop] + sigmaG*as.vector(t(chol(K)) %*% epsilonG)
u <- up - muP[ped.df$pop]
expy <- rlnorm(N, 
               muP[ped.df$pop] + sigmaG*as.vector(t(chol(K)) %*% epsilonG),
               sigmaR)
y <- log(expy)
ggplot(data.frame(y = y, u = u, pop = as.factor(ped.df$pop)), 
       aes(u, y, col = pop)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  geom_hline(yintercept = muP[ped.df$pop], linetype = "dotted")
```

```{r simnormdistlognorm1fit, echo = T}
mNLn <- stan_model("variance_models/methods/VarNormDistLognorm.stan")
fNLn <- sampling(mNLn, chains = 2, save_warmup = F, data = mdata,
                 control = list(adapt_delta = 0.99, max_treedepth = 12))
broom::tidyMCMC(fNLn, ess = T, rhat = T, 
                estimate.method = "median", droppars = F,
                pars = c("mu", "sigma", "lp__"))
mcmc_trace(as.array(fNLn, pars = c("mu", "sigma"))) +
   geom_hline(aes(yintercept = expected), col = "red", 
           data = data.frame(parameter = c("mu[1]", "mu[2]", 
                                           "sigma[1]", "sigma[2]"), 
                               expected = c(muP, sigmaR, sigmaG)))
```

#### Lognormal distribution 2

And if we know use a lognormal distribution with location on the median :

$$e^y \sim \mathcal {logN}(log(u''),\sigma_R)\\log(u'') \sim \mathcal{MVN}(\mu_P,\sigma_G.K)\\u'= log(u'')=u+\mu_p$$

Equivalent to:

$$e^y \sim \mathcal {logN}(log(u''),\sigma_R)\\ u'' \sim \mathcal{MVlogN}(\mu_P,\sigma_G.K)\\ u''=e^u.e^\mu_p$$

Equivalent to:

$$e^y \sim \mathcal {logN}(log(u''),\sigma_R)\\ u'' \sim \mathcal{MVlogN}(log(\mu_P'),\sigma_G.K)\\ log(\mu_p') = \mu_p \\ u''=e^u.e^\mu_p=e^u.\mu_p'$$

Than we can rewrite as:

$$e^y \sim \mathcal {logN}(log(e^{log(\mu_P') + \sigma_G.A.a}),\sigma_R)\\a \sim \mathcal{N}(0,1)\\|~u'' = e^{log(\mu_P') + \sigma_G.A.a}\\log(\mu_p') = \mu_p\\e^u=\frac{u''}{\mu_P'}$$

Equivalent to:

$$e^y \sim \mathcal {logN}(\mu_P + \sigma_G.A.a,\sigma_R)\\a \sim \mathcal{N}(0,1)\\|~u'' = e^{log(\mu_P') + \sigma_G.A.a}\\u = log(u'') - log(\mu_p') = \sigma_G.A.a$$

Once non-centered it's totally the same model as the previous one.

```{r simnormdistlognorm2data, fig.cap="Normal simulated data.", echo = T}
u <- sigmaG*as.vector(t(chol(K)) %*% epsilonG)
expy <- rlnorm(N, 
               log(exp(muP[ped.df$pop])) + sigmaG*as.vector(t(chol(K)) %*% epsilonG),
               sigmaR)
y <- log(expy)
ggplot(data.frame(y = y, u = u, pop = as.factor(ped.df$pop)), 
       aes(u, y, col = pop)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  geom_hline(yintercept = muP[ped.df$pop], linetype = "dotted")
```

#### Comparison

```{r simnormcomparison, echo = T}
lapply(lapply(c(fNN, fNLn), get_elapsed_time), data.frame) %>%
  bind_rows(.id = "model") %>% 
  mutate(model = recode_factor(model, 
                               "1" = "Normal distribution",
                               "2" = "Lognormal distribution")) %>% 
  mutate(total = warmup + sample) %>% 
  arrange(total)
lapply(c(fNN, fNLn), mcmc_intervals_data, pars = "lp__") %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = recode_factor(model, 
                               "1" = "Normal distribution",
                               "2" = "Lognormal distribution")) %>% 
  ggplot(aes(x = model, xend = model,
             color = model, fill = model)) +
  geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
  geom_segment(aes(y = ll, yend = hh),
               size = 1, show.legend = F, alpha = 0.5) +
  geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
  coord_flip() +
  xaxis_title(F) + 
  ylab("Loglikelihood") +
  scale_color_discrete(guide = "none") +
  scale_fill_discrete(guide = "none")
```

### Lognormal data

#### Normal distribution

And similarly if $y$ has a lognormal distribution, we can write with a normal distribution :

$$log(y) \sim \mathcal N(u',\sigma_R)\\u' \sim \mathcal{MVN}(\mu_P,\sigma_G.K)\\u'=u+\mu_p$$

Than we can rewrite as:

$$log(y) \sim \mathcal N(\mu_P + \sigma_G.A.a,\sigma_R)\\a \sim \mathcal{N}(0,1)\\|~u' =\mu_P + \sigma_G.A.a\\u=\sigma_G.A.a$$

```{r simlognormaldistnorm1, fig.cap="Logormal simulated data.", echo = T}
up <- muP[ped.df$pop] + sigmaG*as.vector(t(chol(K)) %*% epsilonG) 
u <- up - muP[ped.df$pop]
logy <- rnorm(N, 
              muP[ped.df$pop] + sigmaG*as.vector(t(chol(K)) %*% epsilonG),
              sigmaR)
y <- exp(logy)
ggplot(data.frame(y = y, u = u, pop = as.factor(ped.df$pop)), 
       aes(u, y, col = pop)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  geom_hline(yintercept = exp(muP[ped.df$pop]), linetype = "dotted")
```

```{r simlognormdistnorm1fit, echo = T}
mLnN <- stan_model("variance_models/methods/VarLognormDistNorm.stan")
fLnN <- sampling(mLnN, chains = 2, save_warmup = F, data = mdata,
                 control = list(adapt_delta = 0.99, max_treedepth = 12))
broom::tidyMCMC(fLnN, ess = T, rhat = T, 
                estimate.method = "median", droppars = F,
                pars = c("mu", "sigma", "lp__"))
mcmc_trace(as.array(fLnN, pars = c("mu", "sigma"))) +
   geom_hline(aes(yintercept = expected), col = "red", 
           data = data.frame(parameter = c("mu[1]", "mu[2]", 
                                           "sigma[1]", "sigma[2]"), 
                               expected = c(muP, sigmaR, sigmaG)))
```

#### Lognormal distribution 1

And if we know use a lognormal distribution

$$y \sim \mathcal {logN}(u',\sigma_R)\\u' \sim \mathcal{MVN}(\mu_P,\sigma_G.K)\\u'=u+\mu_p$$

Than we can rewrite as:

$$y \sim \mathcal {logN}(\mu_P + \sigma_G.A.a,\sigma_R)\\a \sim \mathcal{N}(0,1)\\|~u' = \sigma_G.A.a\\u=\mu_P + \sigma_G.A.a$$

```{r simlognormaldistlognorm1, fig.cap="Normal simulated data.", echo = T}
up <- muP[ped.df$pop] + sigmaG*as.vector(t(chol(K)) %*% epsilonG)
u <- up - muP[ped.df$pop]
y <- rlnorm(N, 
            muP[ped.df$pop] + sigmaG*as.vector(t(chol(K)) %*% epsilonG),
            sigmaR)
ggplot(data.frame(y = y, u = u, pop = as.factor(ped.df$pop)), 
       aes(u, y, col = pop)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  geom_hline(yintercept = exp(muP[ped.df$pop]), linetype = "dotted")
```

```{r simlognormdistlognorm1fit, echo = T}
mLnLn <- stan_model("variance_models/methods/VarLognormDistLognorm.stan")
fLnLn <- sampling(mLnLn, chains = 2, save_warmup = F, data = mdata,
                 control = list(adapt_delta = 0.99, max_treedepth = 12))
broom::tidyMCMC(fLnLn, ess = T, rhat = T, 
                estimate.method = "median", droppars = F,
                pars = c("mu", "sigma", "lp__"))
mcmc_trace(as.array(fLnLn, pars = c("mu", "sigma"))) +
   geom_hline(aes(yintercept = expected), col = "red", 
           data = data.frame(parameter = c("mu[1]", "mu[2]", 
                                           "sigma[1]", "sigma[2]"), 
                               expected = c(muP, sigmaR, sigmaG)))
```

#### Comparison

```{r simlognormcomparison, echo = T}
lapply(lapply(c(fLnN, fLnLn), get_elapsed_time), data.frame) %>%
  bind_rows(.id = "model") %>% 
  mutate(model = recode_factor(model, 
                               "1" = "Normal distribution",
                               "2" = "Lognormal distribution")) %>% 
  mutate(total = warmup + sample) %>% 
  arrange(total)
lapply(c(fNN, fNLn), mcmc_intervals_data, pars = "lp__") %>% 
  bind_rows(.id = "model") %>% 
  mutate(model = recode_factor(model, 
                               "1" = "Normal distribution",
                               "2" = "Lognormal distribution")) %>% 
  ggplot(aes(x = model, xend = model,
             color = model, fill = model)) +
  geom_point(aes(y = m), shape = 21, size = 3, alpha = 0.5) +
  geom_segment(aes(y = ll, yend = hh),
               size = 1, show.legend = F, alpha = 0.5) +
  geom_segment(aes(y = l, yend = h), size = 2, alpha = 0.5) +
  coord_flip() +
  xaxis_title(F) + 
  ylab("Loglikelihood") +
  scale_color_discrete(guide = "none") +
  scale_fill_discrete(guide = "none")
```
