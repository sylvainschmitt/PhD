```{r setup_variant, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(kableExtra)
if(knitr:::is_html_output()) options(knitr.table.format = "html") 
if(knitr:::is_latex_output()) options(knitr.table.format = "latex") 
library(tidyverse)
library(Biostrings)
library(GenomicAlignments)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
  cache = T, cache.lazy = F)
path <- "~/Documents/BIOGECO/PhD/data/Symphonia_Paracou/"
```

```{r variant}
```

# Variant call

We used `GATK` as it has apparently similar performance to other variant callers [@Supernat2018] and was more known by Myriam. For that we used the following pipeline:

1. __Variant calling__ Run the `HaplotypeCaller` on each sample's BAM files to create single-sample gVCFs using the `.g.vcf` extension for the output file.
1. __Data aggregation__ Aggregate the GVCF files and feed in one GVCF to be genotyped with `GenomicsDBImport` or `CombineGVCFs`
1. __Joint genotyping__ Run `GenotypeGVCFs` on all of them together to create the raw SNP and indel VCFs that are usually emitted by the callers.
1. __Variant recalibration__ Resume the classic GATK Best Practices workflow by running `VQSR` on these "regular" VCFs according to GATK usual recommendations.

## Variant calling

Run the `HaplotypeCaller` on each sample's BAM files to create single-sample gVCFs using the `.g.vcf` extension for the output file.

```{bash HaplotypeCaller, eval=F, echo=T}
#!/bin/bash
#SBATCH --time=48:00:00
#SBATCH -J HaplotypeCaller
#SBATCH -o HaplotypeCaller_output.out
#SBATCH -e HaplotypeCaller_error.out
#SBATCH --mem=160G
#SBATCH --cpus-per-task=40
#SBATCH --mail-type=BEGIN,END,FAIL

module purge
module load bioinfo/gatk-4.0.0.0
module load bioinfo/picard-2.14.1
module load bioinfo/samtools-1.4

# java -Xmx4g -jar $PICARD CreateSequenceDictionary R=reference/reference.fasta O=reference/reference.dict
# samtools faidx reference/reference.fasta
N=40 # number of threads
(
for file in $(ls mapping/bam/*.bam)
do 
   ((i=i%N)); ((i++==0)) && wait
   gatk --java-options "-Xmx4G" HaplotypeCaller -R reference/reference.fasta -I $file -O variantCalling/gvcf/$(basename "${file%.*}").g.vcf.gz  -ERC GVCF & 
done
)
```

## Data aggregation

Aggregate the GVCF files and feed in one GVCF to be genotyped with `GenomicsDBImport` or `CombineGVCFs`

```{bash GenomicsDBImport, eval=F, echo=T}
#!/bin/bash
#SBATCH --time=36:00:00
#SBATCH -J GenomicsDBImport
#SBATCH -o GenomicsDBImport_output.out
#SBATCH -e GenomicsDBImport_error.out
#SBATCH --mem=40G
#SBATCH --cpus-per-task=20
#SBATCH --mail-type=BEGIN,END,FAIL

module purge
module load bioinfo/gatk-4.0.0.0

#make sample map code
mkdir tmp
gatk --java-options "-Xmx4g -Xms4g" GenomicsDBImport \
  --genomicsdb-workspace-path haplotypeDB \
  - L X \ #mandatory
  --sample-name-map sample_map \
  --tmp-dir=tmp \
  --batch-size 50
rm -r tmp
```

```{bash CombineGVCFs, eval=F, echo=T}
#!/bin/bash
#SBATCH --time=36:00:00
#SBATCH -J CombineGVCFs
#SBATCH -o CombineGVCFs_output.out
#SBATCH -e CombineGVCFs_error.out
#SBATCH --mem=40G
#SBATCH --cpus-per-task=20
#SBATCH --mail-type=BEGIN,END,FAIL

# slower !
module purge
module load bioinfo/gatk-4.0.0.0

# command to be generated automatically
gatk CombineGVCFs \
 -R referenceMappingAll/reference.fasta \
 --variant sample1.g.vcf.gz \
 --variant sample2.g.vcf.gz \
 -O reference.g.vcf.gz
```

## Joint genotyping

Run `GenotypeGVCFs` on all of them together to create the raw SNP and indel VCFs that are usually emitted by the callers.

```{bash GenotypeGVCFsDB, eval=F, echo=T}
#!/bin/bash
#SBATCH --time=36:00:00
#SBATCH -J GenotypeGVCFsDB
#SBATCH -o GenotypeGVCFsDB_output.out
#SBATCH -e GenotypeGVCFsDB_error.out
#SBATCH --mem=40G
#SBATCH --cpus-per-task=20
#SBATCH --mail-type=BEGIN,END,FAIL

module purge
module load bioinfo/gatk-4.0.0.0

mkdir tmp
gatk --java-options "-Xmx4g" GenotypeGVCFs \
 -R referenceMappingAll/reference.fasta \
 -V gendb://haplotypeDB \
 -O reference.vcf.gz \
 --tmp-dir=tmp
rm -r tmp
```

```{bash GenotypeGVCFs, eval=F, echo=T}
#!/bin/bash
#SBATCH --time=36:00:00
#SBATCH -J GenotypeGVCFs
#SBATCH -o GenotypeGVCFs_output.out
#SBATCH -e GenotypeGVCFs_error.out
#SBATCH --mem=40G
#SBATCH --cpus-per-task=20
#SBATCH --mail-type=BEGIN,END,FAIL

module purge
module load bioinfo/gatk-4.0.0.0

gatk --java-options "-Xmx4g" GenotypeGVCFs \
 -R referenceMappingAll/reference.fasta \
 -V reference.g.vcf.gz \
 -O reference.preVQSR.vcf.gz
```

## Variant recalibration

Resume the classic GATK Best Practices workflow by running `VQSR` on these "regular" VCFs according to GATK usual recommendations.

```{bash VQSR, eval=F, echo=T}
#!/bin/bash
#SBATCH --time=36:00:00
#SBATCH -J VQSR
#SBATCH -o VQSR_output.out
#SBATCH -e VQSRs_error.out
#SBATCH --mem=40G
#SBATCH --cpus-per-task=20
#SBATCH --mail-type=BEGIN,END,FAIL

module purge
module load bioinfo/gatk-4.0.0.0

mkdir tranches
gatk ApplyVQSR \
   -R referenceMappingAll/reference.fasta \
   -V reference.preVQSR.vcf.gz \
   -O reference.vcf.gz \
   --recal-file output.recal \ # missing one step !
   -mode SNP
```
