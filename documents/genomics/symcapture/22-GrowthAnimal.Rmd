```{r setup_growthanimal, include=FALSE}
# rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(kableExtra)
if(knitr:::is_html_output()) options(knitr.table.format = "html") 
if(knitr:::is_latex_output()) options(knitr.table.format = "latex") 
library(tidyverse)
library(raster)
library(bayesplot)
library(kinship2)
library(rstan)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
  cache = F, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
load("./symcapture_save/Env2.Rdata")
trees <- trees %>% 
  na.omit(pop) %>% # remove admixed
  dplyr::select(Ind, IID, pop, Plot, SubPlot, TreeFieldNum, Y0, DBH0, DBHtoday)
pathCluster <- "~/Remotes/genotoul/work/PhD/documents/genomics/symcapture"
```

# Growth & Animal models

## Introduction

The aim of this document is to explore animal and growth model with generated data to validate their behavior and use it on *Symphonia* and *Eschweilera* real data. 

## Tes 1 - Simulated Kinship

Let's consider a set of $P$ populations including each $Fam$ families composed of $I = 14$ individuals with arbitrar relationships.

```{r kinship1, fig.cap="Kinship matrix"}
kin.df <- function(P= 3, Fam = 6){
  I <- 14 # Individuals
  data.frame(pop = rep(1:P, each = Fam*I),
                       fam = rep(1:Fam, each = I),
                       ind = rep(1:I, Fam*P),
                       father = rep(c(NA, NA, 1, 1, 1, 1, NA, 6, 6, 6, NA, 11, 11, 11), Fam*P),
                       mother = rep(c(NA, NA, 2, 2, 2, 2, NA, 7, 7, 7, NA, 3, 3, 3), Fam*P), 
                       sex = rep(c(1, 2, 2, 3, 3, 1, 2, 3, 3, 3, 1, 3, 3, 3), Fam*P)) %>% 
    mutate_at(c("father", "mother"), funs(ifelse(!is.na(.), paste0(pop,fam,.), NA))) %>% 
    mutate(ind = paste0(pop,fam,ind))
}
kin.mat <- function(P = 3, Fam = 6){
  ped.df <- kin.df(P, Fam)
  ped.ped <- pedigree(id = ped.df$ind, dadid = ped.df$father, momid = ped.df$mother, sex = ped.df$sex, famid = paste0(ped.df$pop, ped.df$fam))
  K <- as.matrix(kinship(ped.ped))
  K <- 2*K
}
heatmap(kin.mat(3, 6))
```

```{r gdata}
gdata <- function(
  I = 100, # Nb ind
  Y = 33, # Nb years
  P = 3, # Nb pops
  Gmax = c(0.54, 0.53, 0.44), # model parameters
  Dopt =  c(27, 31, 20),
  Ks = c(0.67, 0.73, 0.64),
  # sigmaR = c(0.16, 9, 0.22),
  sigmaR = c(0.1, 0.01, 0.01), # for lognormals
  sigma = 0.14
){
  Gmax <- Gmax[1:P]
  Dopt <- Dopt[1:P]
  Ks <- Ks[1:P]
  years <- 1984:(1984+Y-1)
  pop <- sample(1:P, I, replace = T)
  Init <- sample_n(trees, I)
  DBH0 <- Init$DBH0
  Y0 <- Init$Y0
  # Gmaxi <- truncnorm::rtruncnorm(I, mean = Gmax[pop], sd = sqrt(sigmaR[1]), a = 0.1)
  # Dopti <- truncnorm::rtruncnorm(I, mean = Dopt[pop], sd = sqrt(sigmaR[2]), a = 10, b = 50)
  # Ksi <- truncnorm::rtruncnorm(I, mean = Ks[pop], sd = sqrt(sigmaR[3]), a = 0.2, b = 1)
  Gmaxi <- rlnorm(I, mean = log(Gmax[pop])+sqrt(sigmaR[1])/2, sd = sqrt(sigmaR[1]))
  Dopti <- rlnorm(I, mean = log(Dopt[pop])+sqrt(sigmaR[2])/2, sd = sqrt(sigmaR[2]))
  Ksi <- rlnorm(I, mean = log(Ks[pop])+sqrt(sigmaR[3])/2, sd = sqrt(sigmaR[3]))
  DBH <- rep(NA, I)
  for (t in 1:(Y-1)) {
    for(i in 1:I){
      if(years[t] == Y0[i]) 
        DBH[i] <- DBH0[i] 
    }
    DBH <- DBH + Gmaxi * exp(-0.5*(log(DBH / Dopti) / Ksi) * (log(DBH / Dopti) / Ksi))
  }
  DBH <- DBH - DBH0
  DBHtoday <- DBH0 + rlnorm(I, log(DBH), sdlog = sqrt(sigma)) + 10^-6
  list(params = list(Gmax = Gmax, Dopt = Dopt, Ks = Ks, 
                     sigmaR = sigmaR, sigma = sigma),
       data = data.frame(ind = 1:I, pop = pop, 
                         DBH0 = DBH0, Y0 = Y0, Y = Y, DBHtoday = DBHtoday),
       mdata = list(I = I, Y = Y, P = P, years = years, DBH0 = DBH0,
                    Y0 = Y0, DBHtoday = DBHtoday, pop = pop))
}
# data.frame(
#   Dopti = c(
#     rnorm(I, mean = Gmax[pop], sd = sqrt(sigmaR[1])),
#     # rlnorm(I, mean = log(Gmax[pop]), sd = sqrt(sigmaR[1]))
#     rlnorm(I, mean = log(Gmax[pop]), sd = log(sqrt(sigmaR[1])/Gmax[pop]^2+1))
#   ),
#   law = rep(c("Normal", "Lognormal"), each = I)
# ) %>% ggplot(aes(Dopti, fill = law)) + geom_density(alpha = 0.3) + geom_vline(xintercept = Gmax[pop])
```

```{r gkdata}
gkdata <- function(
  P = 3, # Nb pops
  Fam = 6, # Nb family
  Y = 33, # Nb years
  Gmax = c(0.54, 0.53, 0.44), # model parameters
  Dopt =  c(27, 31, 20),
  Ks = c(0.67, 0.73, 0.64),
  # sigmaR = c(0.16, 9, 0.22),
  sigmaR = c(0.1, 0.01, 0.01), # for lognormals
  sigmaG = c(0.37, 25, 0.38),
  sigma = 0.14
){
  K <- kin.mat(P, Fam)
  Kdf <- kin.df(P, Fam)
  I <- nrow(K)
  Gmax <- Gmax[1:P]
  Dopt <- Dopt[1:P]
  Ks <- Ks[1:P]
  years <- 1984:(1984+Y-1)
  pop <- sample(1:P, I, replace = T)
  Init <- sample_n(trees, I)
  DBH0 <- Init$DBH0
  Y0 <- Init$Y0
  uG <- truncnorm::rtruncnorm(I, sd = sqrt(sigmaG[1]), a = -Gmax[Kdf$pop] + 0.1, b = 2-Gmax[Kdf$pop])
  uD <- truncnorm::rtruncnorm(I, sd = sqrt(sigmaG[2]), a = -Dopt[Kdf$pop] + 1, b = 100 -Dopt[Kdf$pop])
  uK <- truncnorm::rtruncnorm(I, sd = sqrt(sigmaG[3]), a = -Ks[Kdf$pop] + 0.2, b = 1.5 -Ks[Kdf$pop])
  Gmaxi <- rlnorm(I, mean = log(Gmax[pop] + as.vector(t(chol(K)) %*% uG))+sqrt(sigmaR[1])/2, sd = sqrt(sigmaR[1]))
  Dopti <- rlnorm(I, mean = log(Dopt[pop] + as.vector(t(chol(K)) %*% uD))+sqrt(sigmaR[2])/2, sd = sqrt(sigmaR[2]))
  Ksi <- rlnorm(I, mean = log(Ks[pop] + as.vector(t(chol(K)) %*% uK))+sqrt(sigmaR[3])/2, sd = sqrt(sigmaR[3]))
  # Gmaxi <- truncnorm::rtruncnorm(I, mean = Gmax[Kdf$pop] + as.vector(t(chol(K)) %*% uG),
  #                                sd = sqrt(sigmaR[1]), a = 0)
  # Dopti <- truncnorm::rtruncnorm(I, mean = Dopt[Kdf$pop] + as.vector(t(chol(K)) %*% uD), 
  #                                sd = sqrt(sigmaR[2]), a = 0)
  # Ksi <- truncnorm::rtruncnorm(I, mean = Ks[Kdf$pop] + as.vector(t(chol(K)) %*% uK), 
  #                              sd = sqrt(sigmaR[3]), a = 0)
  DBH <- rep(NA, I)
  for (t in 1:(Y-1)) {
    for(i in 1:I){
      if(years[t] == Y0[i]) 
        DBH[i] <- DBH0[i] 
    }
    DBH <- DBH + Gmaxi * exp(-0.5*(log(DBH / Dopti) / Ksi) * (log(DBH / Dopti) / Ksi))
  }
  DBH <- DBH - DBH0
  DBHtoday <- DBH0 + rlnorm(I, log(DBH), sdlog = sqrt(sigma)) + 10^-6
  list(params = list(Gmax = Gmax, Dopt = Dopt, Ks = Ks, 
                     sigmaR = sigmaR, sigmaG = sigmaG, sigma = sigma),
       data = data.frame(ind = 1:I, pop = pop, 
                         DBH0 = DBH0, Y0 = Y0, Y = Y, DBHtoday = DBHtoday),
       mdata = list(I = I, Y = Y, P = P, years = years, DBH0 = DBH0,
                    Y0 = Y0, DBHtoday = DBHtoday, pop = pop, K = K))
}
```

### Genotype

We use the following simple animal model to estimate variance associated to the genotype:

$$y \sim \mathcal N(\mu + A.a,\sigma_R)~|~a \sim \mathcal N(0,\sigma_G)$$

```{r genotype1Data, fig.cap="Data used for the simple animal model."}
# K <- kin.mat(1, 6)
# sigmaY <- 1
# sigmaG <- 0.3
# sigmaR <- sigmaY - sigmaG
# N <- nrow(K)
# mu <- rnorm(1)
# u <- rnorm(N, sd = sqrt(sigmaG))
# r <- rnorm(N, sd = sqrt(sigmaR))
# y <- mu + as.vector(t(chol(K)) %*% u) + r
# animal1 <- stan_model("symcapture_models/Animal1.stan")
# fitAnimal1 <- sampling(animal1, chains = 2, save_warmup = F, data = list(N = N, Y = y, K = K))
# save(K, sigmaY, sigmaG, sigmaR, N, mu, u, r, y, fitAnimal1,
#      file = file.path("symcapture_save", "animal1.Rdata"))
load(file.path("symcapture_save", "animal1.Rdata"))
ggplot(data.frame(y = y, u = u), aes(u, y)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  xlab("Breeding values") + ylab("Observed values")
```

```{r genotype1Table}
broom::tidyMCMC(fitAnimal1, pars = c("mu", "sigmaG", "sigmaR"), 
                droppars = NULL, rhat = T) %>% 
  mutate(expected = c(mu, var(u), var(r))) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Simple animal model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r genotype1Fig, fig.cap="Parameters for simple Animal model traceplot and expected value in red."}
mcmc_trace(as.array(fitAnimal1, pars = c("mu", "sigmaG", "sigmaR"))) +
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c("mu", "sigmaG", "sigmaR"), 
                               expected = c(mu, var(u), var(r))))
```

### Population & Genotype

We added a fixed effect for population on the intercept of the previous model to capture both population and genotype variations:

$$y \sim \mathcal N(\mu_p + A.a,\sigma_R)~|~a \sim \mathcal N(o,\sigma_G)$$

```{r pop1Data, fig.cap="Data used for the animal model with population effect."}
# P = 3
# Fam = 6
# K <- kin.mat(P, Fam)
# ped.df <- kin.df(P, Fam)
# sigmaP <- 0.8
# sigmaG <- 0.8
# sigmaR <- 0.2
# N <- nrow(K)
# p <- rnorm(P, sd = sqrt(sigmaP))
# u <- rnorm(N, sd = sqrt(sigmaG))
# r <- rnorm(N, sd = sqrt(sigmaR))
# y <- p[ped.df$pop] + as.vector(t(chol(K)) %*% u) + r
# animal2 <- stan_model("symcapture_models/Animal2.stan")
# fitAnimal2 <- sampling(animal2, chains = 2, save_warmup = F,
#                        data = list(N = N, Y = y, K = K, P = P, population = ped.df$pop))
# save(P, Fam, K, ped.df, sigmaP, sigmaG, sigmaR, N, p, u, r, y, fitAnimal2,
#      file = file.path("symcapture_save", "animal2.Rdata"))
load(file.path("symcapture_save", "animal2.Rdata"))
ggplot(data.frame(y = y, u = u, pop = as.factor(ped.df$pop)),
       aes(u, y, col = pop)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  xlab("Breeding values") + ylab("Observed values") +
  scale_color_discrete("Population")
```

```{r pop1Table}
broom::tidyMCMC(fitAnimal2, pars = c("mu", "sigmaG", "sigmaR"), 
                droppars = NULL, rhat = T) %>% 
  mutate(expected = c(p, var(u), var(r))) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Animal model with population effects fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r pop1Fig, fig.cap="Parameters for Animal model with population effects traceplot and expected value in red."}
mcmc_trace(as.array(fitAnimal2, pars = c("mu", "sigmaG", "sigmaR"))) +
    geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c(paste0("mu[", 1:3, "]"), "sigmaG", "sigmaR"), 
                               expected = c(p, var(u), var(r))))
```

### Gmax

$$DBH_{y=today,p,i} - DBH_{y=y0,p,i} \sim \mathcal{logN} (\sum _{y=y_0} ^{y=today} Gmax_i.exp(-\frac12.[\frac{log(\frac{DBH_{y,p,i}}{Dopt_p})}{Ks_p}]^2), \sigma)$$
$$Gmax_i \sim \mathcal {logN} (Gmax_p, \sigma^2_{R})$$

```{r gamx1Data, fig.cap="Data used for the individual growth model combined with population animal model."}
# mdata <- gdata(I = 10*7, P = 1, sigmaR = c(0.1, 0, 0))
# gmax1 <- stan_model("./symcapture_models/GrowthGmax.stan")
# fitGmax1 <- sampling(gmax1, chains = 2, data = mdata$mdata, save_warmup = F,
#                      control = list(adapt_delta = 0.9, max_treedepth = 12),
#                      include = F, pars = c("DBH", "theta_raw", "thetai_raw", "Gaxi"))
# save(mdata, fitGmax1, file = file.path("symcapture_save", "gmax.Rdata"))  # End cluster
load(file = file.path("symcapture_save", "growth.Rdata"))
ggplot(mdata$data, aes(x = DBH0, y = DBHtoday, col = Y0)) + 
  geom_point() + geom_abline() + 
  xlab("DBH at recruitment") + ylab("DBH today") +
  viridis::scale_color_viridis("Year of recruitment")
```

```{r gmax1Tab}
broom::tidyMCMC(fitGmax1, pars = c("theta", "sigmaR", "sigma", "lp__"), 
                         droppars = NULL, rhat = T) %>% 
  mutate(expected = c(unlist(mdata$params)[c(1:4, 7)], NA)) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Individual growth model combined with population animal model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r gmax1Fig, fig.cap="Parameters for individual growth model combined with population animal model traceplot and expected value in red."}
mcmc_trace(as.array(fitGmax1, pars = c("theta", "sigmaR", "sigma"))) + 
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c(paste0("theta[1,", 1:3, "]"), "sigmaR", "sigma"), 
                               expected = unlist(mdata$params)[c(1:4,7)]))
```

```{r gmax1Fig2, fig.cap="Obtained versus expected growth trajectories."}
ggplot(data.frame(DBH = 0:200, AGR = 2), aes(x = DBH, y = AGR)) +
  stat_function(aes(col = "Expected"), fun = function(.x) 
    mdata$params$Gmax*exp(-.5*(log(.x/mdata$params$Dopt)/mdata$params$Ks)^2)) +
  stat_function(aes(col = "Obtained"), fun = function(.x) 
    mean(as.array(fitGmax1, "theta[1,1]"))*
      exp(-.5*(log(.x/mean(as.array(fitGmax1, "theta[1,2]")))/mean(as.array(fitGmax1, "theta[1,3]")))^2))
```

### Growth

We modeled the individual growth as the difference of DBH between tree recruitment and today being the sum of all year growth from the rcruitment to today:

$$DBH_{y=today,p,i} - DBH_{y=y0,p,i} \sim \mathcal{logN} (\sum _{y=y_0} ^{y=today} Gmax_i.exp(-\frac12.[\frac{log(\frac{DBH_{y,p,i}}{Dopt_i})}{Ks_i}]^2), \sigma)$$
$$\mid \forall \theta \in [Gmax, Dopt,Ks], \theta_i \sim \mathcal {logN} (\theta_p, \sigma^2_{R_{\theta}})$$

```{r growth1Data, fig.cap="Data used for the individual growth model combined with population animal model."}
# mdata <- gdata(I = 15*7, P = 1)
# growth1 <- stan_model("./symcapture_models/GrowthLog.stan")
# fitGrowth1 <- sampling(growth1, chains = 2, data = mdata$mdata, save_warmup = F,
#                        control = list(adapt_delta = 0.9, max_treedepth = 12),
#                        include = F, pars = c("DBH", "theta_raw", "thetai_raw",
#                                              "sigmaR_raw", "thetai"))
# save(mdata, fitGrowth1, file = file.path("symcapture_save", "growth.Rdata"))  # End cluster
# load(file = file.path("symcapture_save", "growth.Rdata"))
ggplot(mdata$data, aes(x = DBH0, y = DBHtoday, col = Y0)) + 
  geom_point() + geom_abline() + 
  xlab("DBH at recruitment") + ylab("DBH today") +
  viridis::scale_color_viridis("Year of recruitment")
```

```{r growth1Tab}
broom::tidyMCMC(fitGrowth1, pars = c("theta", "sigmaR", "sigma", "lp__"), 
                         droppars = NULL, rhat = T) %>% 
  mutate(expected = c(unlist(mdata$params), NA)) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Individual growth model combined with population animal model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r growth1Fig, fig.cap="Parameters for individual growth model combined with population animal model traceplot and expected value in red."}
mcmc_trace(as.array(fitGrowth1, pars = c("theta", "sigmaR", "sigma"))) + 
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c(paste0("theta[1,", 1:3, "]"),
                                             paste0("sigmaR[", 1:3, "]"), "sigma"), 
                               expected = unlist(mdata$params)))
```

```{r growth1Fig2, fig.cap="Obtained versus expected growth trajectories."}
ggplot(data.frame(DBH = 0:200, AGR = 2), aes(x = DBH, y = AGR)) +
  stat_function(aes(col = "Expected"), fun = function(.x) 
    mdata$params$Gmax*exp(-.5*(log(.x/mdata$params$Dopt)/mdata$params$Ks)^2)) +
  stat_function(aes(col = "Obtained"), fun = function(.x) 
    mean(as.array(fitGrowth1, "theta[1,1]"))*
      exp(-.5*(log(.x/mean(as.array(fitGrowth1, "theta[1,2]")))/mean(as.array(fitGrowth1, "theta[1,3]")))^2))
```

### Gmax & Genotype

$$DBH_{y=today,p,i} - DBH_{y=y0,p,i} \sim \mathcal{logN} (\sum _{y=y_0} ^{y=today} Gmax_i.exp(-\frac12.[\frac{log(\frac{DBH_{y,p,i}}{Dopt_p})}{Ks_p}]^2), \sigma)$$
$$Gmax_i \sim \mathcal{logN} (Gmax_p+A.a, \sigma^2_{R}),a\sim\mathcal N(0,\sigma_{G})$$

```{r gmaxgeno1Data, fig.cap="Data used for the individual growth and genotype model."}
# mdata <- gkdata(Fam = 10, P = 1, sigmaR = c(0.1, 0, 0), sigmaG = c(0.2, 0, 0))
# gmaxgeno <- stan_model("./symcapture_models/GmaxGeno.stan")
# fitGmaxGeno <- sampling(gmaxgeno, chains = 2, data = mdata$mdata, save_warmup = F,
#                           control = list(adapt_delta = 0.9, max_treedepth = 12),
#                           include = F, pars = c("DBH", "theta_raw", "thetai_raw", "a_raw",
#                                                 "sigmaR_raw", "sigmaG_raw", "Gmaxi", "a"))
# save(mdata, fitGmaxGeno, file = file.path("symcapture_save", "growthgeno1.Rdata")) # End cluster
load(file = file.path("symcapture_save", "growthgeno1.Rdata"))
ggplot(mdata$data, aes(x = DBH0, y = DBHtoday, col = Y0)) + 
  geom_point() + geom_abline() + 
  xlab("DBH at recruitment") + ylab("DBH today") +
  viridis::scale_color_viridis("Year of recruitment")
```

```{r gmaxgeno1Tab}
broom::tidyMCMC(fitGmaxGeno, 
                pars = c("theta", "sigmaR", "sigmaG", "sigma"),
                droppars = NULL, rhat = T) %>%
  mutate(expected = unlist(mdata$params)[c(1:4,7,10)]) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Individual growth model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r gmaxgeno1Fig, fig.cap="Parameters for individual growth model traceplot and expected value in red."}
mcmc_trace(as.array(fitGmaxGeno, 
                    pars = c("theta", "sigmaR", "sigmaG", "sigma"))) + 
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c("theta[1,1]", "theta[1,2]", "theta[1,3]",
                                             paste0("sigmaR"),
                                             paste0("sigmaG"), "sigma"), 
                               expected = unlist(mdata$params)[c(1:4,7,10)]))
```

```{r gmax1Fig2, fig.cap="Obtained versus expected growth trajectories."}
ggplot(data.frame(DBH = 0:200, AGR = 2), aes(x = DBH, y = AGR)) +
  stat_function(aes(col = "Expected"), fun = function(.x) 
    mdata$params$Gmax*exp(-.5*(log(.x/mdata$params$Dopt)/mdata$params$Ks)^2)) +
  stat_function(aes(col = "Obtained"), fun = function(.x) 
    mean(as.array(fitGmaxGeno, "theta[1,1]"))*
      exp(-.5*(log(.x/mean(as.array(fitGmaxGeno, "theta[1,2]")))/mean(as.array(fitGmaxGeno, "theta[1,3]")))^2))
```

### Growth & Genotype

$$DBH_{y=today,p,i} - DBH_{y=y0,p,i} \sim \mathcal{logN} (\sum _{y=y_0} ^{y=today} Gmax_i.exp(-\frac12.[\frac{log(\frac{DBH_{y,p,i}}{Dopt_i})}{Ks_i}]^2), \sigma)$$
$$\mid \forall \theta \in [Gmax, Dopt,Ks], \theta_i \sim \mathcal {logN} (\theta_p+A.a_\theta, \sigma^2_{R_{\theta}}),a_\theta\sim\mathcal N(0,\sigma_{G_\theta})$$

```{r growthgeno1Data, fig.cap="Data used for the individual growth and genotype model."}
mdata <- gkdata(Fam = 6, P = 1)
growthgeno <- stan_model("./symcapture_models/GrowthGenoLog.stan")
fitGrowthGeno <- sampling(growthgeno, chains = 2, data = mdata$mdata, save_warmup = F,
                          control = list(adapt_delta = 0.9, max_treedepth = 12),
                          include = F, pars = c("DBH", "theta_raw", "thetai_raw", "a_raw",
                                                "sigmaR_raw", "sigmaG_raw", "thetai", "a"))
save(mdata, fitGrowthGeno, file = file.path("symcapture_save", "growthgeno1.Rdata")) # End cluster
load(file = file.path("symcapture_save", "growthgeno1.Rdata"))
ggplot(mdata$data, aes(x = DBH0, y = DBHtoday, col = Y0)) + 
  geom_point() + geom_abline() + 
  xlab("DBH at recruitment") + ylab("DBH today") +
  viridis::scale_color_viridis("Year of recruitment")
```

```{r growthgeno1Tab}
broom::tidyMCMC(fitGrowthGeno, 
                pars = c("theta", "sigmaR", "sigmaG", "sigma"),
                droppars = NULL, rhat = T) %>%
  mutate(expected = c(unlist(mdata$params))) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Individual growth model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r growthgeno1Fig, fig.cap="Parameters for individual growth model traceplot and expected value in red."}
mcmc_trace(as.array(fitGrowthGeno, 
                    pars = c("theta", "sigmaR", "sigmaG", "sigma"))) + 
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c("theta[1,1]", "theta[1,2]", "theta[1,3]",
                                             paste0("sigmaR[", 1:3, "]"),
                                             paste0("sigmaG[", 1:3, "]"), "sigma"), 
                               expected = c(unlist(mdata$params))))
```

## Test2 - Symphonia Kinship

We then used our own Kinship matrix to validate it's use and transformation. Specifically we used the kinship matrix built with `VCFTools` with coefficients between 0 and 0.5 and negative coefficients due to population structure. We set negative coefficient to 0 to not coufound with the population specific intercept. Then we multiplied the matrix by 2 to have a variance of 1. Finally, we used `Matrix::nearPD` function to find the closest matrix positive definite for Cholesky decomposition.

```{r kinship2, fig.cap="Prepared Kinship matrix for Symphonia individuals (no negative values, positive definite, and varying from 0 to 1."}
path <- "~/Documents/BIOGECO/PhD/data/Symphonia_Paracou/Sequences/populationGenomics/"
fam <- read_delim(file.path(path, "gemma", "Gmax0", "paracou3pop.fam"), delim = " ",
                  col_names = c("FID", "IID", "PAT", "MAT", "SEX", "PHENOTYPE"))
inds <- unique(trees$IID)
K <- read_tsv(file.path(path, "..", "variantCalling", "paracou", "out.relatedness2"))  %>% 
  reshape2::dcast(INDV1 ~ INDV2, value.var = "RELATEDNESS_PHI") %>% 
  column_to_rownames("INDV1") %>% 
  as.matrix()
K <- K[inds, inds]
K[K < 0] <- 0
K <- K*2
K <- as.matrix(nearPD(K)$mat)
heatmap(K)
```

### Genotype

We use the following simple animal model to estimate variance associated to the genotype:

$$y \sim \mathcal N(\mu + A.a,\sigma_R)~|~a \sim \mathcal N(0,\sigma_G)$$

```{r genotype2Data, fig.cap="Data used for the simple animal model."}
# sigmaY <- 1
# sigmaG <- 0.3
# sigmaR <- sigmaY - sigmaG
# N <- nrow(K)
# mu <- rnorm(1)
# u <- rnorm(N, sd = sqrt(sigmaG))
# r <- rnorm(N, sd = sqrt(sigmaR))
# y <- mu + as.vector(t(chol(K)) %*% u) + r
# animal1 <- stan_model("symcapture_models/Animal1.stan")
# fitAnimal1 <- sampling(animal1, chains = 2, save_warmup = F,
#                        control = list(adapt_delta = 0.9, max_treedepth = 12),
#                        data = list(N = N, Y = y, K = K))
# save(K, sigmaY, sigmaG, sigmaR, N, mu, u, r, y, fitAnimal1,
#      file = file.path("symcapture_save", "animal1_real.Rdata"))
load(file.path("symcapture_save", "animal1_real.Rdata"))
ggplot(data.frame(y = y, u = u), aes(u, y)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  xlab("Breeding values") + ylab("Observed values")
```

```{r genotype2Table}
broom::tidyMCMC(fitAnimal1, pars = c("mu", "sigmaG", "sigmaR"), 
                droppars = NULL, rhat = T) %>% 
  mutate(expected = c(mu, var(u), var(r))) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Simple animal model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r genotype2Fig, fig.cap="Parameters for simple Animal model traceplot and expected value in red."}
mcmc_trace(as.array(fitAnimal1, pars = c("mu", "sigmaG", "sigmaR"))) +
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c("mu", "sigmaG", "sigmaR"), 
                               expected = c(mu, var(u), var(r))))
```

### Population & Genotype

We added a fixed effect for population on the intercept of the previous model to capture both population and genotype variations:

$$y \sim \mathcal N(\mu_p + A.a,\sigma_R)~|~a \sim \mathcal N(o,\sigma_G)$$

```{r pop2Data, fig.cap="Data used for the animal model with population effect."}
# pop <- dplyr::select(trees, IID, pop) %>% unique() %>% 
#   mutate(popNum = as.numeric(as.factor(pop))) %>% dplyr::select(popNum) %>% unlist()
# P <- max(pop)
# sigmaP <- 0.5
# sigmaG <- 0.3
# sigmaR <- 0.2
# N <- nrow(K)
# p <- rnorm(P, sd = sqrt(sigmaP))
# u <- rnorm(N, sd = sqrt(sigmaG))
# r <- rnorm(N, sd = sqrt(sigmaR))
# y <- p[pop] + as.vector(t(chol(K)) %*% u) + r
# animal2 <- stan_model("symcapture_models/Animal2.stan")
# fitAnimal2 <- sampling(animal2, chains = 2, save_warmup = F,
#                        data = list(N = N, Y = y, K = K, P = P, population = pop))
# save(P, K, sigmaP, sigmaG, sigmaR, N, p, u, r, y, pop, fitAnimal2,
#      file = file.path("symcapture_save", "animal2_real.Rdata"))
load(file.path("symcapture_save", "animal2_real.Rdata"))
ggplot(data.frame(y = y, u = u, pop = as.factor(pop)),
       aes(u, y, col = pop)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  xlab("Breeding values") + ylab("Observed values") +
  scale_color_discrete("Population")
```

```{r pop2Table}
broom::tidyMCMC(fitAnimal2, pars = c("mu", "sigmaG", "sigmaR"), 
                droppars = NULL, rhat = T) %>% 
  mutate(expected = c(p, sigmaG, sigmaR)) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Animal model with population effects fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r pop2Fig, fig.cap="Parameters for Animal model with population effects traceplot and expected value in red."}
mcmc_trace(as.array(fitAnimal2, pars = c("mu", "sigmaG", "sigmaR"))) +
    geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c(paste0("mu[", 1:3, "]"), "sigmaG", "sigmaR"), 
                               expected = c(p, sigmaG, sigmaR)))
```
