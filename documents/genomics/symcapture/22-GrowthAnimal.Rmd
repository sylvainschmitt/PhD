```{r setup_growthanimal, include=FALSE}
# rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(kableExtra)
if(knitr:::is_html_output()) options(knitr.table.format = "html") 
if(knitr:::is_latex_output()) options(knitr.table.format = "latex") 
library(tidyverse)
library(raster)
library(bayesplot)
library(kinship2)
library(rstan)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
  cache = F, cache.lazy = F)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
load("./symcapture_save/Env2.Rdata")
trees <- trees %>% 
  na.omit(pop) %>% # remove admixed
  filter(Y0 < 2007) %>%
  dplyr::select(Ind, IID, pop, Plot, SubPlot, TreeFieldNum, Y0, DBH0, DBHtoday, N)
pathCluster <- "~/Remotes/genotoul/work/PhD/documents/genomics/symcapture"
```

# Growth & Animal models

## Introduction

The aim of this document is to explore animal and growth model with generated data to validate their behavior and use it on *Symphonia* and *Eschweilera* real data. 

## Test Animal 1 - Simulated Kinship

Let's consider a set of $P$ populations including each $Fam$ families composed of $I = 14$ individuals with arbitrar relationships.

```{r kinship1, fig.cap="Kinship matrix"}
kin.df <- function(P= 3, Fam = 6){
  I <- 14 # Individuals
  data.frame(pop = rep(1:P, each = Fam*I),
                       fam = rep(1:Fam, each = I),
                       ind = rep(1:I, Fam*P),
                       father = rep(c(NA, NA, 1, 1, 1, 1, NA, 6, 6, 6, NA, 11, 11, 11), Fam*P),
                       mother = rep(c(NA, NA, 2, 2, 2, 2, NA, 7, 7, 7, NA, 3, 3, 3), Fam*P), 
                       sex = rep(c(1, 2, 2, 3, 3, 1, 2, 3, 3, 3, 1, 3, 3, 3), Fam*P)) %>% 
    mutate_at(c("father", "mother"), funs(ifelse(!is.na(.), paste0(pop,fam,.), NA))) %>% 
    mutate(ind = paste0(pop,fam,ind))
}
kin.mat <- function(P = 3, Fam = 6){
  ped.df <- kin.df(P, Fam)
  ped.ped <- pedigree(id = ped.df$ind, dadid = ped.df$father, momid = ped.df$mother, sex = ped.df$sex, famid = paste0(ped.df$pop, ped.df$fam))
  K <- as.matrix(kinship(ped.ped))
  K <- 2*K
}
heatmap(kin.mat(3, 6))
```

```{r gkdata}
gkdata <- function(
  P = 3, # Nb pops
  Fam = 6, # Nb family
  Y = 33, # Nb years
  Gmax = c(0.54, 0.53, 0.44),
  Dopt = c(27, 31, 20)/100,
  Ks = c(0.67, 0.73, 0.64),
  sigmaR = c(0.4, 0.8, 0.4), 
  sigmaG = c(0.2, 0.4, 0.2), 
  sigma = 0.05
){
  K <- kin.mat(P, Fam)
  Kdf <- kin.df(P, Fam)
  I <- nrow(K)
  Gmax <- Gmax[1:P]
  Dopt <- Dopt[1:P]
  Ks <- Ks[1:P]
  years <- 1984:(1984+Y-1)
  pop <- sample(1:P, I, replace = T)
  Init <- sample_n(trees, I)
  DBH0 <- Init$DBH0
  Y0 <- Init$Y0
  
  Gmaxi <- exp(log(as.vector(t(chol(K)) %*% exp(log(Gmax[pop]) + sigmaG[1]*rnorm(I)))) +
                 + sigmaR[1]*rnorm(I))
  Dopti <- exp(log(as.vector(t(chol(K)) %*% exp(log(Dopt[pop]) + sigmaG[2]*rnorm(I)))) +
                 + sigmaR[2]*rnorm(I))
  Ksi <- exp(log(as.vector(t(chol(K)) %*% exp(log(Ks[pop]) + sigmaG[3]*rnorm(I)))) +
               + sigmaR[3]*rnorm(I))
  
  DBH <- rep(NA, I)
  for (t in 1:(Y-1)) {
    for(i in 1:I){
      if(years[t] == Y0[i]) 
        DBH[i] <- DBH0[i] 
    }
    DBH <- DBH + Gmaxi * exp(-0.5*(log(DBH / (100*Dopti)) / Ksi)^2)
  }
  DBH <- DBH - DBH0
  DBHtoday <- DBH0 + rlnorm(I, log(DBH), sdlog = sigma)
  list(params = list(Gmax = Gmax, Dopt = Dopt, Ks = Ks, 
                     sigmaR = sigmaR, sigmaG = sigmaG, sigma = sigma),
       data = data.frame(ind = 1:I, pop = pop, 
                         DBH0 = DBH0, Y0 = Y0, Y = Y, DBHtoday = DBHtoday),
       mdata = list(I = I, Y = Y, P = P, years = years, DBH0 = DBH0,
                    Y0 = Y0, DBHtoday = DBHtoday, pop = pop, K = K),
       fun = gkdata)
}
```

### Genotype

We use the following simple animal model to estimate variance associated to the genotype:

$$y \sim \mathcal N(\mu + A.a,\sigma_R)~|~a \sim \mathcal N(0,\sigma_G)$$

```{r genotype1Data, fig.cap="Data used for the simple animal model."}
# K <- kin.mat(1, 6)
# sigmaY <- 1
# sigmaG <- 0.3
# sigmaR <- sigmaY - sigmaG
# N <- nrow(K)
# mu <- rnorm(1)
# u <- rnorm(N, sd = sqrt(sigmaG))
# r <- rnorm(N, sd = sqrt(sigmaR))
# y <- mu + as.vector(t(chol(K)) %*% u) + r
# animal1 <- stan_model("symcapture_models/Animal1.stan")
# fitAnimal1 <- sampling(animal1, chains = 2, save_warmup = F, data = list(N = N, Y = y, K = K))
# save(K, sigmaY, sigmaG, sigmaR, N, mu, u, r, y, fitAnimal1,
#      file = file.path("symcapture_save", "animal1.Rdata"))
load(file.path("symcapture_save", "animal1.Rdata"))
ggplot(data.frame(y = y, u = u), aes(u, y)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  xlab("Breeding values") + ylab("Observed values")
```

```{r genotype1Table}
broom::tidyMCMC(fitAnimal1, pars = c("mu", "sigmaG", "sigmaR"), 
                droppars = NULL, rhat = T) %>% 
  mutate(expected = c(mu, var(u), var(r))) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Simple animal model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r genotype1Fig, fig.cap="Parameters for simple Animal model traceplot and expected value in red."}
mcmc_trace(as.array(fitAnimal1, pars = c("mu", "sigmaG", "sigmaR"))) +
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c("mu", "sigmaG", "sigmaR"), 
                               expected = c(mu, var(u), var(r))))
```

### Population & Genotype

We added a fixed effect for population on the intercept of the previous model to capture both population and genotype variations:

$$y \sim \mathcal N(\mu_p + A.a,\sigma_R)~|~a \sim \mathcal N(o,\sigma_G)$$

```{r pop1Data, fig.cap="Data used for the animal model with population effect."}
# P = 3
# Fam = 6
# K <- kin.mat(P, Fam)
# ped.df <- kin.df(P, Fam)
# sigmaP <- 0.8
# sigmaG <- 0.8
# sigmaR <- 0.2
# N <- nrow(K)
# p <- rnorm(P, sd = sqrt(sigmaP))
# u <- rnorm(N, sd = sqrt(sigmaG))
# r <- rnorm(N, sd = sqrt(sigmaR))
# y <- p[ped.df$pop] + as.vector(t(chol(K)) %*% u) + r
# animal2 <- stan_model("symcapture_models/Animal2.stan")
# fitAnimal2 <- sampling(animal2, chains = 2, save_warmup = F,
#                        data = list(N = N, Y = y, K = K, P = P, population = ped.df$pop))
# save(P, Fam, K, ped.df, sigmaP, sigmaG, sigmaR, N, p, u, r, y, fitAnimal2,
#      file = file.path("symcapture_save", "animal2.Rdata"))
load(file.path("symcapture_save", "animal2.Rdata"))
ggplot(data.frame(y = y, u = u, pop = as.factor(ped.df$pop)),
       aes(u, y, col = pop)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  xlab("Breeding values") + ylab("Observed values") +
  scale_color_discrete("Population")
```

```{r pop1Table}
broom::tidyMCMC(fitAnimal2, pars = c("mu", "sigmaG", "sigmaR"), 
                droppars = NULL, rhat = T) %>% 
  mutate(expected = c(p, var(u), var(r))) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Animal model with population effects fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r pop1Fig, fig.cap="Parameters for Animal model with population effects traceplot and expected value in red."}
mcmc_trace(as.array(fitAnimal2, pars = c("mu", "sigmaG", "sigmaR"))) +
    geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c(paste0("mu[", 1:3, "]"), "sigmaG", "sigmaR"), 
                               expected = c(p, var(u), var(r))))
```
 
## Test Animal 2 - Symphonia Kinship

We then used our own Kinship matrix to validate it's use and transformation. Specifically we used the kinship matrix built with `VCFTools` with coefficients between 0 and 0.5 and negative coefficients due to population structure. We set negative coefficient to 0 to not coufound with the population specific intercept. Then we multiplied the matrix by 2 to have a variance of 1. Finally, we used `Matrix::nearPD` function to find the closest matrix positive definite for Cholesky decomposition.

```{r kinship2, fig.cap="Prepared Kinship matrix for Symphonia individuals (no negative values, positive definite, and varying from 0 to 1."}
path <- "~/Documents/BIOGECO/PhD/data/Symphonia_Paracou/Sequences/populationGenomics/"
fam <- read_delim(file.path(path, "gemma", "Gmax0", "paracou3pop.fam"), delim = " ",
                  col_names = c("FID", "IID", "PAT", "MAT", "SEX", "PHENOTYPE"))
inds <- unique(trees$IID)
K <- read_tsv(file.path(path, "..", "variantCalling", "paracou", "out.relatedness2"))  %>% 
  reshape2::dcast(INDV1 ~ INDV2, value.var = "RELATEDNESS_PHI") %>% 
  column_to_rownames("INDV1") %>% 
  as.matrix()
K <- K[inds, inds]
K[K < 0] <- 0
K <- K*2
K <- as.matrix(nearPD(K)$mat)
heatmap(K)
```

### Genotype

We use the following simple animal model to estimate variance associated to the genotype:

$$y \sim \mathcal N(\mu + A.a,\sigma_R)~|~a \sim \mathcal N(0,\sigma_G)$$

```{r genotype2Data, fig.cap="Data used for the simple animal model."}
# sigmaY <- 1
# sigmaG <- 0.3
# sigmaR <- sigmaY - sigmaG
# N <- nrow(K)
# mu <- rnorm(1)
# u <- rnorm(N, sd = sqrt(sigmaG))
# r <- rnorm(N, sd = sqrt(sigmaR))
# y <- mu + as.vector(t(chol(K)) %*% u) + r
# animal1 <- stan_model("symcapture_models/Animal1.stan")
# fitAnimal1 <- sampling(animal1, chains = 2, save_warmup = F,
#                        control = list(adapt_delta = 0.9, max_treedepth = 12),
#                        data = list(N = N, Y = y, K = K))
# save(K, sigmaY, sigmaG, sigmaR, N, mu, u, r, y, fitAnimal1,
#      file = file.path("symcapture_save", "animal1_real.Rdata"))
load(file.path("symcapture_save", "animal1_real.Rdata"))
ggplot(data.frame(y = y, u = u), aes(u, y)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  xlab("Breeding values") + ylab("Observed values")
```

```{r genotype2Table}
broom::tidyMCMC(fitAnimal1, pars = c("mu", "sigmaG", "sigmaR"), 
                droppars = NULL, rhat = T) %>% 
  mutate(expected = c(mu, var(u), var(r))) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Simple animal model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r genotype2Fig, fig.cap="Parameters for simple Animal model traceplot and expected value in red."}
mcmc_trace(as.array(fitAnimal1, pars = c("mu", "sigmaG", "sigmaR"))) +
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c("mu", "sigmaG", "sigmaR"), 
                               expected = c(mu, var(u), var(r))))
```

### Population & Genotype

We added a fixed effect for population on the intercept of the previous model to capture both population and genotype variations:

$$y \sim \mathcal N(\mu_p + A.a,\sigma_R)~|~a \sim \mathcal N(o,\sigma_G)$$

```{r pop2Data, fig.cap="Data used for the animal model with population effect."}
# pop <- dplyr::select(trees, IID, pop) %>% unique() %>% 
#   mutate(popNum = as.numeric(as.factor(pop))) %>% dplyr::select(popNum) %>% unlist()
# P <- max(pop)
# sigmaP <- 0.5
# sigmaG <- 0.3
# sigmaR <- 0.2
# N <- nrow(K)
# p <- rnorm(P, sd = sqrt(sigmaP))
# u <- rnorm(N, sd = sqrt(sigmaG))
# r <- rnorm(N, sd = sqrt(sigmaR))
# y <- p[pop] + as.vector(t(chol(K)) %*% u) + r
# animal2 <- stan_model("symcapture_models/Animal2.stan")
# fitAnimal2 <- sampling(animal2, chains = 2, save_warmup = F,
#                        data = list(N = N, Y = y, K = K, P = P, population = pop))
# save(P, K, sigmaP, sigmaG, sigmaR, N, p, u, r, y, pop, fitAnimal2,
#      file = file.path("symcapture_save", "animal2_real.Rdata"))
load(file.path("symcapture_save", "animal2_real.Rdata"))
ggplot(data.frame(y = y, u = u, pop = as.factor(pop)),
       aes(u, y, col = pop)) +
  geom_point() + geom_smooth(method = "lm", se = F) +
  xlab("Breeding values") + ylab("Observed values") +
  scale_color_discrete("Population")
```

```{r pop2Table}
broom::tidyMCMC(fitAnimal2, pars = c("mu", "sigmaG", "sigmaR"), 
                droppars = NULL, rhat = T) %>% 
  mutate(expected = c(p, sigmaG, sigmaR)) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Animal model with population effects fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r pop2Fig, fig.cap="Parameters for Animal model with population effects traceplot and expected value in red."}
mcmc_trace(as.array(fitAnimal2, pars = c("mu", "sigmaG", "sigmaR"))) +
    geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c(paste0("mu[", 1:3, "]"), "sigmaG", "sigmaR"), 
                               expected = c(p, sigmaG, sigmaR)))
```

## Test Growth


```{r gdata}
gdata <- function(
  I = 100, # Nb ind
  Y = 33, # Nb years
  P = 3, # Nb pops
  Gmax = c(0.54, 0.53, 0.44),
  Dopt = c(27, 31, 20)/100,
  Ks = c(0.67, 0.73, 0.64),
  sigmaR = c(0.6, 0.8, 0.6), 
  sigma = 0.05
){
  Gmax <- Gmax[1:P]
  Dopt <- Dopt[1:P]
  Ks <- Ks[1:P]
  years <- 1984:(1984+Y-1)
  pop <- sample(1:P, I, replace = T)
  Init <- sample_n(trees, I)
  DBH0 <- Init$DBH0
  Y0 <- Init$Y0

  Gmaxi <- rlnorm(I, meanlog = log(Gmax[pop]), sdlog = sigmaR[1])
  Dopti <- rlnorm(I, meanlog = log(Dopt[pop]), sdlog = sigmaR[2])
  Ksi <- rlnorm(I, meanlog = log(Ks[pop]), sdlog = sigmaR[3])
  
  DBH <- rep(NA, I)
  for (t in 1:(Y-1)) {
    for(i in 1:I){
      if(years[t] == Y0[i]) 
        DBH[i] <- DBH0[i] 
    }
    DBH <- DBH + Gmaxi * exp(-0.5*(log(DBH / (100*Dopti)) / Ksi)^2)
  }
  DBH <- DBH - DBH0
  DBHtoday <- DBH0 + rlnorm(I, meanlog = log(DBH), sdlog = sigma)
  list(params = list(Gmax = Gmax, Dopt = Dopt, Ks = Ks, 
                     sigmaR = sigmaR, sigma = sigma),
       data = data.frame(ind = 1:I, pop = pop, 
                         DBH0 = DBH0, Y0 = Y0, Y = Y, DBHtoday = DBHtoday),
       mdata = list(I = I, Y = Y, P = P, years = years, DBH0 = DBH0,
                    Y0 = Y0, DBHtoday = DBHtoday, pop = pop),
       fun = gdata)
}
pairs_stan <- function(chain, stan_model, pars) {
  energy <- as.matrix(sapply(get_sampler_params(stan_model, inc_warmup = F), 
                             function(x) x[,"energy__"]))
  pars <- extract(stan_model, pars = pars, permuted = F)
  df <- data.frame(energy[,chain], pars[,chain,])
  names(df)[1] <- "energy"
  GGally::ggpairs(df, title = paste0("Chain", chain), 
                  lower = list(continuous = GGally::wrap("points", alpha = 0.2)))                    
}
```

```{r gmaxdata, fig.cap="Data used for the individual growth model combined with population animal model."}
# mdata <- gdata(I = 332, P = 1, Gmax = 0.54, sigmaR = c(0.5, 0, 0), sigma = 0.15)
# save(mdata, file = file.path("symcapture_save", "gmaxData.Rdata"))
load(file = file.path("symcapture_save", "gmaxData.Rdata"))
# save(mdatabis, file = file.path("symcapture_save", "gmaxDataF.Rdata"))
load(file = file.path("symcapture_save", "gmaxDataF.Rdata"))
ggplot(mdata$data, aes(x = DBH0, y = DBHtoday, col = Y0)) + 
  geom_point() + geom_abline() + 
  xlab("DBH at recruitment") + ylab("DBH today") +
  viridis::scale_color_viridis("Year of recruitment") +
  coord_equal() +
  ggtitle("Simulated data")
ggplot(mdatabis$data, aes(x = DBH0, y = DBHtoday, col = Y0)) + 
  geom_point() + geom_abline() + 
  xlab("DBH at recruitment") + ylab("DBH today") +
  viridis::scale_color_viridis("Year of recruitment") +
  coord_equal() +
  ggtitle("Simulated filtered data")
ggplot(trees, aes(x = DBH0, y = DBHtoday, col = Y0, shape = pop)) + 
  geom_point() + geom_abline() + 
  xlab("DBH at recruitment") + ylab("DBH today") +
  viridis::scale_color_viridis("Year of recruitment") +
  coord_equal() +
  ggtitle("Real filtered data")
```

### Gmax 1 - $DBH_{today} - DBH_0$

$$DBH_{y=today,p,i}  - DBH_{y=y0,p,i} \sim \mathcal{logN} ( \\ log(\sum _{y=y_0} ^{y=today} e^{DBH_{y=y0,p,i} + log(Gmax_p) + \sigma^2_{R1}.Gmax_i}.exp(-\frac12.[\frac{log(\frac{DBH_{y,p,i}}{Dopt_p})}{Ks_p}]^2)), \sigma^2) \\ Gmax_i \sim \mathcal N(0, 1) $$

```{r gamx1Tab}
# gmax1 <- stan_model("./symcapture_models/Gmax.stan")
# fitGmax1 <- sampling(gmax1, chains = 2, data = mdata$mdata, save_warmup = F,
#                      control = list(adapt_delta = 0.99, max_treedepth = 12))
# save(mdata, fitGmax1, file = file.path("symcapture_save", "gmax1.Rdata"))
load(file = file.path("symcapture_save", "gmax1.Rdata"))
broom::tidyMCMC(fitGmax1, pars = c("theta", "sigmaR", "sigma", "lp__"), 
                         droppars = NULL, ess = T, rhat = T, estimate.method = "median") %>% 
  mutate(expected = c(unlist(mdata$params)[c(1:4, 7)], NA)) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat, ess) %>% 
  kable(caption = "Individual growth model combined with population animal model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$", "$N_{eff}$"))
```

```{r gmax1Trace, fig.cap="Traceplot of model parameters and expected value in red."}
mcmc_trace(as.array(fitGmax1, pars = c("theta", "sigmaR", "sigma", "lp__")),
           np = nuts_params(fitGmax1)) + 
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c(paste0("theta[1,", 1:3, "]"),
                                             "sigmaR", "sigma", "lp__"),
                               expected = c(unlist(mdata$params)[c(1:4,7)], NA)))
```

```{r gmax1Pairs, message=FALSE}
pairs_stan(1, fitGmax1, c("theta", "sigmaR", "sigma"))
```

```{r gmax1Energy}
mcmc_nuts_energy(nuts_params(fitGmax1))
```

```{r gmax1Sigma}
as.data.frame(fitGmax1, c("sigmaR", "sigma", "lp__")) %>%
  ggplot(aes(x= sigmaR, y = sigma, col = lp__)) + geom_point()
```

```{r gmax1Pred, fig.cap="Obtained versus expected growth trajectories."}
ggplot(data.frame(DBH = 0:200, AGR = 2), aes(x = DBH, y = AGR)) +
   geom_vline(xintercept = mdata$data$DBH0, alpha = 0.1) +
  stat_function(aes(col = "Expected"), fun = function(.x) 
    mdata$params$Gmax*exp(-.5*(log(.x/(100*mdata$params$Dopt))/mdata$params$Ks)^2)) +
  stat_function(aes(col = "Obtained"), fun = function(.x) 
    mean(as.array(fitGmax1, "theta[1,1]"))*
      exp(-.5*(log(.x/(100*mean(as.array(fitGmax1, "theta[1,2]"))))
               /mean(as.array(fitGmax1, "theta[1,3]")))^2))
```

```{r gmax1Pred2}
as.data.frame(fitGmax1, c("DBH", "lp__")) %>% 
  filter(lp__ ==  max(lp__)) %>% 
  sample_n(1) %>% 
  dplyr::select(-lp__) %>% 
  reshape2::melt(NULL, value.name = "predicted") %>% 
  mutate(DBH0 = mdata$data$DBH0, DBHtoday = mdata$data$DBHtoday) %>% 
  mutate(observed = (DBHtoday - DBH0)) %>% 
  ggplot(aes(x= observed, y = predicted)) + 
  geom_abline(col = "lightgrey") +
  geom_point(alpha = 0.3) +
  ggtitle("Sum of growth (without DBH0)")
```

### Gmax 1bis - $DBH_{today} - DBH_0$

$$DBH_{y=today,p,i}  - DBH_{y=y0,p,i} \sim \mathcal{logN} ( \\ log(\sum _{y=y_0} ^{y=today} e^{DBH_{y=y0,p,i} + log(Gmax_p) + \sigma^2_{R1}.Gmax_i}.exp(-\frac12.[\frac{log(\frac{DBH_{y,p,i}}{Dopt_p})}{Ks_p}]^2)), \sigma^2) \\ Gmax_i \sim \mathcal N(0, 1) $$

```{r gamx1bisTab}
# gmax1bis <- stan_model("./symcapture_models/Gmaxbis.stan")
# fitGmax1bis <- sampling(gmax1bis, chains = 2, data = mdatabis$mdata, save_warmup = F,
#                         control = list(adapt_delta = 0.99, max_treedepth = 12))
# save(mdatabis, fitGmax1bis, file = file.path("symcapture_save", "gmax1bis.Rdata"))
load(file = file.path("symcapture_save", "gmax1bis.Rdata"))
broom::tidyMCMC(fitGmax1bis, pars = c("theta", "sigmaR", "sigma", "lp__"), 
                droppars = NULL, ess = T, rhat = T, estimate.method = "median") %>% 
  mutate(expected = c(unlist(mdatabis$params)[c(1:4, 7)], NA)) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat, ess) %>% 
  kable(caption = "Individual growth model combined with population animal model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$", "$N_{eff}$"))
```

```{r gmax1bisTrace, fig.cap="Traceplot of model parameters and expected value in red."}
mcmc_trace(as.array(fitGmax1bis, pars = c("theta", "sigmaR", "sigma", "lp__")),
           np = nuts_params(fitGmax1bis)) + 
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c(paste0("theta[1,", 1:3, "]"),
                                             "sigmaR", "sigma", "lp__"),
                               expected = c(unlist(mdatabis$params)[c(1:4,7)], NA)))
```

```{r gmax1bisPairs, message=FALSE}
pairs_stan(1, fitGmax1bis, c("theta", "sigmaR", "sigma"))
```

```{r gmax1bisEnergy}
mcmc_nuts_energy(nuts_params(fitGmax1bis))
```

```{r gmax1bisSigma}
as.data.frame(fitGmax1bis, c("sigmaR", "sigma", "lp__")) %>%
  ggplot(aes(x= sigmaR, y = sigma, col = lp__)) + geom_point()
```

```{r gmax1bisPred, fig.cap="Obtained versus expected growth trajectories."}
ggplot(data.frame(DBH = 0:200, AGR = 2), aes(x = DBH, y = AGR)) +
   geom_vline(xintercept = mdata$data$DBH0, alpha = 0.1) +
  stat_function(aes(col = "Expected"), fun = function(.x) 
    mdata$params$Gmax*exp(-.5*(log(.x/(100*mdata$params$Dopt))/mdata$params$Ks)^2)) +
  stat_function(aes(col = "Obtained"), fun = function(.x) 
    mean(as.array(fitGmax1bis, "theta[1,1]"))*
      exp(-.5*(log(.x/(100*mean(as.array(fitGmax1bis, "theta[1,2]"))))
               /mean(as.array(fitGmax1bis, "theta[1,3]")))^2))
```

```{r gmax1bisPred2}
as.data.frame(fitGmax1bis, c("DBH", "lp__")) %>% 
  filter(lp__ ==  max(lp__)) %>% 
  sample_n(1) %>% 
  dplyr::select(-lp__) %>% 
  reshape2::melt(NULL, value.name = "predicted") %>% 
  mutate(DBH0 = mdatabis$data$DBH0, DBHtoday = mdatabis$data$DBHtoday) %>% 
  mutate(observed = (DBHtoday - DBH0)) %>% 
  ggplot(aes(x= observed, y = predicted)) + 
  geom_abline(col = "lightgrey") +
  geom_point(alpha = 0.3) +
  ggtitle("Sum of growth (without DBH0)")
```

### Gmax 2 - $DBH_{today}$

$$DBH_{y=today,p,i} \sim \mathcal{logN} ( \\ log(DBH_{y=y0,p,i} +\sum _{y=y_0} ^{y=today} e^{DBH_{y=y0,p,i} + log(Gmax_p) + \sigma^2_{R1}.Gmax_i}.exp(-\frac12.[\frac{log(\frac{DBH_{y,p,i}}{Dopt_p})}{Ks_p}]^2)), \sigma^2) \\ Gmax_i \sim \mathcal N(0, 1) $$

```{r gamx2Tab}
# gmax2 <- stan_model("./symcapture_models/Gmax2.stan")
# fitGmax2 <- sampling(gmax2, chains = 2, data = mdata$mdata, save_warmup = F,
#                      control = list(adapt_delta = 0.99, max_treedepth = 12))
# save(mdata, fitGmax2, file = file.path("symcapture_save", "gmax2.Rdata"))
load(file = file.path("symcapture_save", "gmax2.Rdata"))
broom::tidyMCMC(fitGmax2, pars = c("theta", "sigmaR", "sigma", "lp__"), 
                         droppars = NULL, ess = T, rhat = T, estimate.method = "median") %>% 
  mutate(expected = c(unlist(mdata$params)[c(1:4, 7)], NA)) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat, ess) %>% 
  kable(caption = "Individual growth model combined with population animal model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$", "$N_{eff}$"))
```

```{r gmax2Trace, fig.cap="Traceplot of model parameters and expected value in red."}
mcmc_trace(as.array(fitGmax2, pars = c("theta", "sigmaR", "sigma", "lp__")),
           np = nuts_params(fitGmax2)) + 
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c(paste0("theta[1,", 1:3, "]"),
                                             "sigmaR", "sigma", "lp__"),
                               expected = c(unlist(mdata$params)[c(1:4,7)], NA)))
```

```{r gmax2Pairs, message=FALSE}
pairs_stan(1, fitGmax2, c("theta", "sigmaR", "sigma"))
```

```{r gmax2Energy}
mcmc_nuts_energy(nuts_params(fitGmax2))
```

```{r gmax2Sigma}
as.data.frame(fitGmax2, c("sigmaR", "sigma", "lp__")) %>%
  ggplot(aes(x= sigmaR, y = sigma, col = lp__)) + geom_point()
```

```{r gmax2Pred, fig.cap="Obtained versus expected growth trajectories."}
ggplot(data.frame(DBH = 0:200, AGR = 2), aes(x = DBH, y = AGR)) +
   geom_vline(xintercept = mdata$data$DBH0, alpha = 0.1) +
  stat_function(aes(col = "Expected"), fun = function(.x) 
    mdata$params$Gmax*exp(-.5*(log(.x/(100*mdata$params$Dopt))/mdata$params$Ks)^2)) +
  stat_function(aes(col = "Obtained"), fun = function(.x) 
    mean(as.array(fitGmax2, "theta[1,1]"))*
      exp(-.5*(log(.x/(100*mean(as.array(fitGmax2, "theta[1,2]"))))
               /mean(as.array(fitGmax2, "theta[1,3]")))^2))
```

```{r gmax2Pred2}
as.data.frame(fitGmax2, c("DBH", "lp__")) %>% 
  filter(lp__ ==  max(lp__)) %>% 
  sample_n(1) %>% 
  dplyr::select(-lp__) %>% 
  reshape2::melt(NULL, value.name = "predicted") %>% 
  mutate(DBH0 = mdata$data$DBH0, DBHtoday = mdata$data$DBHtoday) %>% 
  mutate(predicted = predicted - DBH0) %>% 
  mutate(observed = (DBHtoday - DBH0)) %>% 
  ggplot(aes(x= observed, y = predicted)) + 
  geom_abline(col = "lightgrey") +
  geom_point(alpha = 0.3) +
  ggtitle("Sum of growth (without DBH0)")
```

### Gmax 3 - $Gmax$

$$\frac{DBH_{y=today,p,i} - DBH_{y=y0,p,i}}{\sum _{y=y_0} ^{y=today}exp(-\frac12.[\frac{log(\frac{DBH_{y,p,i}}{Dopt_p})}{Ks_p}]^2)} \sim \mathcal{logN} (log(Gmax_p) , \sigma^2_R)$$

```{r gamx3Tab}
# gmax3 <- stan_model("./symcapture_models/Gmax3.stan")
# fitGmax3 <- sampling(gmax3, chains = 2, data = mdata$mdata, save_warmup = F,
#                      control = list(adapt_delta = 0.99, max_treedepth = 12))
# save(mdata, fitGmax3, file = file.path("symcapture_save", "gmax3.Rdata"))
load(file = file.path("symcapture_save", "gmax3.Rdata"))
broom::tidyMCMC(fitGmax3, pars = c("theta", "sigmaR", "lp__"), 
                         droppars = NULL, ess = T, rhat = T, estimate.method = "median") %>% 
  mutate(expected = c(unlist(mdata$params)[c(1:4)], NA)) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat, ess) %>% 
  kable(caption = "Individual growth model combined with population animal model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$", "$N_{eff}$"))
```

```{r gmax3Trace, fig.cap="Traceplot of model parameters and expected value in red."}
mcmc_trace(as.array(fitGmax3, pars = c("theta", "sigmaR", "lp__")),
           np = nuts_params(fitGmax3)) + 
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c(paste0("theta[1,", 1:3, "]"),
                                             "sigmaR", "lp__"),
                               expected = c(unlist(mdata$params)[c(1:4)], NA)))
```

```{r gmax3Pairs, message=FALSE}
pairs_stan(1, fitGmax3, c("theta", "sigmaR"))
```

```{r gmax3Energy}
mcmc_nuts_energy(nuts_params(fitGmax3))
```

```{r gmax3Pred, fig.cap="Obtained versus expected growth trajectories."}
ggplot(data.frame(DBH = 0:200, AGR = 2), aes(x = DBH, y = AGR)) +
   geom_vline(xintercept = mdata$data$DBH0, alpha = 0.1) +
  stat_function(aes(col = "Expected"), fun = function(.x) 
    mdata$params$Gmax*exp(-.5*(log(.x/(100*mdata$params$Dopt))/mdata$params$Ks)^2)) +
  stat_function(aes(col = "Obtained"), fun = function(.x) 
    mean(as.array(fitGmax3, "theta[1,1]"))*
      exp(-.5*(log(.x/(100*mean(as.array(fitGmax3, "theta[1,2]"))))
               /mean(as.array(fitGmax3, "theta[1,3]")))^2))
```

```{r gmax3Pred2}
as.data.frame(fitGmax3, c("DBH", "lp__")) %>% 
  filter(lp__ ==  max(lp__)) %>% 
  dplyr::select(-lp__) %>% 
  reshape2::melt(NULL, value.name = "predicted") %>% 
  mutate(DBH0 = mdata$data$DBH0, DBHtoday = mdata$data$DBHtoday) %>% 
  mutate(observed = (DBHtoday - DBH0)) %>% 
  mutate(predicted = predicted*mdata$params$Gmax) %>% 
  ggplot(aes(x= observed, y = predicted)) + 
  geom_abline(col = "lightgrey") +
  geom_point(alpha = 0.3) +
    ggtitle("Sum of growth (without DBH0)")
opts_chunk$set(eval = F)
```

### Gmax - Comparisons

### Growth

$$DBH_{y=today,p,i} - DBH_{y=y0,p,i} \sim \mathcal{logN} (\\log(\sum _{y=y_0} ^{y=today} e^{log(Gmax_p) + \sigma^2_{R1}.Gmax_i}.exp(-\frac12.[\frac{log(\frac{DBH_{y,p,i}}{e^{log(Dopt_p) + \sigma^2_{R2}.Dopt_i}})}{e^{log(Ks_p) + \sigma^2_{R3}.Ks_i}}]^2)), \sigma^2) \\ \mid \forall \theta \in [Gmax, Dopt,Ks], \theta_i \sim \mathcal N(0, 1) $$

```{r growth1Data, fig.cap="Data used for the individual growth model combined with population animal model."}
# mdata <- gdata(I = 372, P = 1, Gmax = 0.54, Dopt = 0.27, Ks = 0.65,
#                sigmaR = c(0.3, 0.3, 0.3), sigma = 0.2)
# growth1 <- stan_model("./symcapture_models/Growth.stan")
# fitGrowth1 <- sampling(growth1, chains = 2, data = mdata$mdata, save_warmup = F,
#                        include = F, pars = c("DBH", "thetai"))
# save(mdata, fitGrowth1, file = file.path("symcapture_save", "growth.Rdata"))
load(file = file.path("symcapture_save", "growth.Rdata"))
ggplot(mdata$data, aes(x = DBH0, y = DBHtoday, col = Y0)) + 
  geom_point() + geom_abline() + 
  xlab("DBH at recruitment") + ylab("DBH today") +
  viridis::scale_color_viridis("Year of recruitment")
```

```{r growth1Tab}
broom::tidyMCMC(fitGrowth1, pars = c("theta", "sigmaR", "sigma", "lp__"), 
                         droppars = NULL, ess = T, rhat = T, estimate.method = "median") %>% 
  mutate(expected = c(unlist(mdata$params), NA)) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat, ess) %>% 
  kable(caption = "Individual growth model combined with population animal model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$", "$N_{eff}$"))
```

```{r growth1Fig, fig.cap="Parameters for individual growth model combined with population animal model traceplot and expected value in red."}
mcmc_trace(as.array(fitGrowth1, pars = c("theta", "sigmaR", "sigma", "lp__")),
           np = nuts_params(fitGrowth1)) +
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c(paste0("theta[1,", 1:3, "]"),
                                             paste0("sigmaR[", 1:3, "]"), "sigma", "lp__"), 
                               expected = c(unlist(mdata$params), NA)))
# mcmc_pairs(as.array(fitGrowth1, pars = c("theta", "sigmaR", "sigma")),
#            np = nuts_params(fitGrowth1))
```

```{r growth1Fig2, fig.cap="Obtained versus expected growth trajectories."}
ggplot(data.frame(DBH = 0:200, AGR = 2), aes(x = DBH, y = AGR)) +
  stat_function(aes(col = "Expected"), fun = function(.x) 
    mdata$params$Gmax*exp(-.5*(log(.x/(100*mdata$params$Dopt))/mdata$params$Ks)^2)) +
  stat_function(aes(col = "Obtained"), fun = function(.x) 
    median(as.array(fitGrowth1, "theta[1,1]"))*
      exp(-.5*(log(.x/(100*median(as.array(fitGrowth1, "theta[1,2]"))))/median(as.array(fitGrowth1, "theta[1,3]")))^2))
```

## Test Growth & Animal

### Gmax & Genotype

$$DBH_{y=today,p,i} - DBH_{y=y0,p,i} \sim \mathcal{logN} ( \\ log(\sum _{y=y_0} ^{y=today} e^{log(Gmax_p) + \sigma^2_{G1}.A.a_i + \sigma^2_{R1}.Gmax_i}. \\ exp(-\frac12.[\frac{log(\frac{DBH_{y,p,i}}{Dopt_p})}{Ks_p}]^2)), \sigma^2) \\ (Gmax_i, a_i) \sim \mathcal N^2(0, 1) $$

```{r gmaxgeno1Data, fig.cap="Data used for the individual growth and genotype model."}
# mdata <- gkdata(Fam = 26, P = 1, Gmax = 0.65, Dopt = 0.27, Ks = 0.65,
#                 sigmaR = c(0.5, 0, 0),
#                 sigmaG = c(0.3, 0, 0),
#                 sigma = 0.2)
# gmaxgeno <- stan_model("./symcapture_models/GmaxGeno2.stan")
# fitGmaxGeno1 <- sampling(gmaxgeno, data = mdata$mdata, save_warmup = F, chains = 2,
#                          include = F, pars = c("DBH", "Gmaxi", "a"))
# save(mdata, fitGmaxGeno1, file = file.path("symcapture_save", "gmaxgeno1.Rdata"))
load(file = file.path("symcapture_save", "gmaxgeno1.Rdata"))
ggplot(mdata$data, aes(x = DBH0, y = DBHtoday, col = Y0)) + 
  geom_point() + geom_abline() + 
  xlab("DBH at recruitment") + ylab("DBH today") +
  viridis::scale_color_viridis("Year of recruitment")
```

```{r gmaxgeno1Tab}
broom::tidyMCMC(fitGmaxGeno1, 
                pars = c("theta", "sigmaR", "sigmaG", "sigma"),
                droppars = NULL, ess = T, rhat = T) %>%
  mutate(expected = unlist(mdata$params)[c(1:4,7,10)]) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat, ess) %>% 
  kable(caption = "Individual growth model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$", "$N_{eff}$"))
```

```{r gmaxgeno1Fig, fig.cap="Parameters for individual growth model traceplot and expected value in red."}
mcmc_trace(as.array(fitGmaxGeno1, 
                    pars = c("theta", "sigmaR", "sigmaG", "sigma", "lp__"))) + 
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c("theta[1,1]", "theta[1,2]", "theta[1,3]",
                                             paste0("sigmaR"),
                                             paste0("sigmaG"), "sigma", "lp__"), 
                               expected = c(unlist(mdata$params)[c(1:4,7,10)], NA)))
# mcmc_pairs(as.array(fitGmaxGeno1, pars = c("theta", "sigmaR", "sigmaG", "sigma")))
mcmc_scatter(fitGmaxGeno1, pars = c("sigma", "lp__"))
# shinystan::launch_shinystan(fitGmaxGeno1)
```

```{r gmaxgeno1Fig2, fig.cap="Obtained versus expected growth trajectories."}
ggplot(data.frame(DBH = 0:200, AGR = 2), aes(x = DBH, y = AGR)) +
  geom_vline(xintercept = mdata$data$DBH0, alpha = 0.1) +
  stat_function(aes(col = "Expected"), fun = function(.x)
    mdata$params$Gmax*exp(-.5*(log(.x/(100*mdata$params$Dopt))/mdata$params$Ks)^2)) +
  stat_function(aes(col = "Obtained"), fun = function(.x) 
    mean(as.array(fitGmaxGeno1, "theta[1,1]"))*
      exp(-.5*(log(.x/(100*mean(as.array(fitGmaxGeno1, "theta[1,2]"))))/mean(as.array(fitGmaxGeno1, "theta[1,3]")))^2))
```

### Growth & Genotype

$$DBH_{y=today,p,i} - DBH_{y=y0,p,i} \sim \mathcal{logN} (\\log(\sum _{y=y_0} ^{y=today} e^{log(Gmax_p) + \sigma^2_{G1}.A.a1_i + \sigma^2_{R1}.Gmax_i} \\ .exp(-\frac12.[\frac{log(\frac{DBH_{y,p,i}}{e^{log(Dopt_p) + \sigma^2_{G2}.A.a2_i + \sigma^2_{R2}.Dopt_i}})}{e^{log(Ks_p) + \sigma^2_{G3}.A.a3_i + \sigma^2_{R3}.Ks_i}}]^2)), \sigma^2) \\ (Gmax_i, Dopt_i,Ks_i,a1_i,a2_i,a3_i) \sim \mathcal N^6(0, 1) $$

```{r growthgeno1Data, fig.cap="Data used for the individual growth and genotype model."}
# mdata <- gkdata(Fam = 6, P = 1)
# growthgeno <- stan_model("./symcapture_models/GrowthGenoLog.stan")
# fitGrowthGeno <- sampling(growthgeno, chains = 2, data = mdata$mdata, save_warmup = F,
#                           control = list(adapt_delta = 0.9, max_treedepth = 12),
#                           include = F, pars = c("DBH", "theta_raw", "thetai_raw", "a_raw",
#                                                 "sigmaR_raw", "sigmaG_raw", "thetai", "a"))
# save(mdata, fitGrowthGeno, file = file.path("symcapture_save", "growthgeno1.Rdata")) 
load(file = file.path("symcapture_save", "growthgeno1.Rdata"))
ggplot(mdata$data, aes(x = DBH0, y = DBHtoday, col = Y0)) + 
  geom_point() + geom_abline() + 
  xlab("DBH at recruitment") + ylab("DBH today") +
  viridis::scale_color_viridis("Year of recruitment")
```

```{r growthgeno1Tab}
broom::tidyMCMC(fitGrowthGeno, 
                pars = c("theta", "sigmaR", "sigmaG", "sigma"),
                droppars = NULL, rhat = T) %>%
  mutate(expected = c(unlist(mdata$params))) %>% 
  dplyr::select(term, estimate, std.error, expected, rhat) %>% 
  kable(caption = "Individual growth model fitted versus expected values.",
        col.names = c("Parameter", "Estimate", "Standard error", 
                      "Expected", "$\\hat R$"))
```

```{r growthgeno1Fig, fig.cap="Parameters for individual growth model traceplot and expected value in red."}
mcmc_trace(as.array(fitGrowthGeno, 
                    pars = c("theta", "sigmaR", "sigmaG", "sigma"))) + 
  geom_hline(aes(yintercept = expected), col = "red", 
             data = data.frame(parameter = c("theta[1,1]", "theta[1,2]", "theta[1,3]",
                                             paste0("sigmaR[", 1:3, "]"),
                                             paste0("sigmaG[", 1:3, "]"), "sigma"), 
                               expected = c(unlist(mdata$params))))
mcmc_pairs(as.array(fitGrowthGeno, pars = c("sigmaR", "sigma")))
```

```{r growthgeno1Fig2, fig.cap="Obtained versus expected growth trajectories."}
ggplot(data.frame(DBH = 0:200, AGR = 2), aes(x = DBH, y = AGR)) +
  geom_vline(xintercept = mdata$data$DBH0, alpha = 0.1) +
  stat_function(aes(col = "Expected"), fun = function(.x) 
    mdata$params$Gmax*exp(-.5*(log(.x/mdata$params$Dopt)/mdata$params$Ks)^2)) +
  stat_function(aes(col = "Obtained"), fun = function(.x) 
    mean(as.array(fitGrowthGeno, "theta[1,1]"))*
      exp(-.5*(log(.x/mean(as.array(fitGrowthGeno, "theta[1,2]")))/mean(as.array(fitGrowthGeno, "theta[1,3]")))^2))
``` 