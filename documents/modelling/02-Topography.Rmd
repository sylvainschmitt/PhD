```{r setuptopo, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(kableExtra)
if(knitr:::is_html_output()) options(knitr.table.format = "html") 
if(knitr:::is_latex_output()) options(knitr.table.format = "latex") 
library(tidyverse)
library(raster)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
  cache = T, cache.lazy = F)
library(ecoevosimulator)
```

# Topography

This chapter aims to develop topography generators and compare theim to the topographic wetness index observed in Parcou plots.
Specifically we want a generator that can be tweaked with few parameters, and that include a flat topography (no topography effect).

## Generators

I developed two generators. One is mathematic, a.k. the sinusoidal topography, and one is algorithmic, a.k. the square-diamond topography.
The sinusoidal topography is based on three parameters, the $grid$ size, the environmental gradient limit $Elim$ and the $amplitude$, and is computed with the following formula:

$$M = sin(amplitude.E \times E')|E=vect(-Elim,Elim)_{grid}$$

The square-diamond topography is computed with the [square-diamond algorithm](https://medium.com/@nickobrien/diamond-square-algorithm-explanation-and-c-implementation-5efa891e486f) (see the scheme below or use the link for a better explanation).

```{r sda, fig.cap="Square diamond algorithm scheme."}
include_graphics("http://jmecom.github.io/images/ds-wikipedia.png")
```

## Paracou plots

Paracou plots show only few bottomlands and plateaus per plot. Globally plots are spatially autocorrelated up to 100 meters and randomly structured after.

```{r plot, fig.cap="Topography wetness index in Paracou plots."}
# wetness <- lapply(1:15, function(P){
#   plot <- src_sqlite(file.path("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/",
#                                "trees", "Paracou.sqlite")) %>% 
#     tbl("Paracou") %>% 
#     filter(Plot == P) %>% 
#     filter(CensusYear == 2015) %>% 
#     collect()
#   coordinates(plot) <- ~Xutm + Yutm
#   proj4string(plot) <- '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
#   wetness <- raster(file.path("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/", 
#                               "topography", "TWI_1m.tif"))
#   dem <- raster(file.path("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/",
#                           "topography", "DEM_1m_2015.tif")) # for CRS
#   projection(wetness) <- projection(dem)
#   wetness <- projectRaster(wetness, crs = '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0')
#   wetness <- crop(wetness, plot)
#   wetness <- as(wetness, "SpatialPixelsDataFrame")
#   wetness <- as.data.frame(wetness)
#   colnames(wetness) <- c("value", "X", "Y")
#   wetness$Plot = P
#   return(wetness)
#   }) %>% 
#   bind_rows()
# write_tsv(wetness, path = "modelling_save/wetness.tsv")
wetness <- read_tsv("modelling_save/wetness.tsv")
ggplot(wetness, aes(X, Y, fill = value)) +
  geom_tile() +
  viridis::scale_fill_viridis() +
  facet_wrap(~ Plot, scales = "free") +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank())
```

```{r plotcor, fig.cap="Spatial autocorrelogram (Moran’s I) of topography wetness index in Paracou."}
# n <- 500
# cor <- lapply(1:15, function(P){
#   t <- wetness %>% 
#     filter(Plot == P) %>% 
#     sample_n(n)
#   pgirmess::correlog(t[c("X", "Y")], t$value, 
#                      method = "Moran", nbclass = 25) %>% 
#     as.data.frame() %>% 
#     mutate(Plot = P)
# }) %>% 
#   bind_rows()
# write_tsv(cor, path = "modelling_save/corwetness.tsv")
cor <- read_tsv("modelling_save/corwetness.tsv")
ggplot(cor, aes(x = dist.class, y = coef, col = as.factor(Plot))) + geom_hline(yintercept = 0) +
  geom_point(aes(alpha = p.value < 0.01)) + geom_line() +
  scale_alpha_manual("p < 0.01", values = c(0.3, 1)) + scale_x_log10() +
  geom_vline(xintercept = c(27, 53), col = "lightgrey", linetype = "dashed") +
  geom_vline(xintercept = 150, col = "lightgrey", linetype = "dotted") +
  xlab("Distance (m)") + ylab("Moran\'s I") + scale_color_discrete("Variable")
```

## Flat topography

Setting the $amplitude$ or the environmental gradient limit $Elim$ to 0 in the sinusoidal topography generator allows the generation of a flat topography as desired to test no effect of topography.

```{r flat, fig.cap="Topography generated with the sinusoidal function for an amplitude of 0, a limit of 0, and a grid of 2^6+1."}
flat <- sinusoidalTopography(grid = 2^6+1, Elim = 0, amplitude = 0)  %>%
  reshape2::melt(NULL) %>% 
  dplyr::rename(X = Var1, Y = Var2)
ggplot(flat, aes(X, Y, fill = value)) +
  geom_tile() +
  viridis::scale_fill_viridis()
```

## Diagonal topography

Setting the $amplitude$ close to 0 and playing with the environmental gradient limit $Elim$ in the sinusoidal topography generator allows the generation of a diagonal topography. The diagonal topography is structured positively between 0-25 cells and above 50 cells. The positive correlation after 100 cells can be problematic compared to TWI in Paracou.

```{r diagonal, fig.cap="Topography generated with the sinusoidal function for an amplitude of 0.01, a variable limit, and a grid of 2^6+1."}
diagonal <- lapply(c(5, 8, 10, 15), function(l)
  sinusoidalTopography(grid = 2^6+1, Elim = l, amplitude = 0.01)  %>%
  reshape2::melt(NULL) %>% 
  dplyr::rename(X = Var1, Y = Var2) %>% 
  mutate(Elim = l)) %>%
  bind_rows()
ggplot(diagonal, aes(X, Y, fill = value)) +
  geom_tile() +
  viridis::scale_fill_viridis() +
  facet_wrap(~ Elim, scales = "free", labeller = "label_both") +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank())
```

```{r diagcor, fig.cap="Spatial autocorrelogram (Moran’s I) of simulated topography."}
n <- 500
cor <- lapply(c(5, 8, 10, 15), function(l){
  t <- diagonal %>% 
    filter(Elim == l) %>% 
    sample_n(n)
  pgirmess::correlog(t[c("X", "Y")], t$value, 
                     method = "Moran", nbclass = 25) %>% 
    as.data.frame() %>% 
    mutate(Elim = l)
}) %>% 
  bind_rows()
ggplot(cor, aes(x = dist.class, y = coef, col = as.factor(Elim))) + geom_hline(yintercept = 0) +
  geom_point(aes(alpha = p.value < 0.01)) + geom_line() +
  scale_alpha_manual("p < 0.01", values = c(0.3, 1)) + scale_x_log10() +
  geom_vline(xintercept = c(27, 53), col = "lightgrey", linetype = "dashed") +
  geom_vline(xintercept = 150, col = "lightgrey", linetype = "dotted") +
  xlab("Distance (m)") + ylab("Moran\'s I") + scale_color_discrete("Variable")
```

## Sinusoidal topography

Playing with the $amplitude$ and setting the environmental gradient limit $Elim$ to 10 in the sinusoidal topography generator allows the generation of a sinusoidal topography. The sinusoidal topography is structured positively at low amplitude but the structure disappear with increasing amplitude. The positive correlation after 100 cells can be problematic compared to TWI in Paracou.

```{r sinusoidal, fig.cap="Topography generated with the sinusoidal function for a variable amplitudz, a limit of 10, and a grid of 2^6+1."}
sinusoidal <- lapply(c(0.01, 0.05, 0.1, 0.5), function(a)
  sinusoidalTopography(grid = 2^6+1, Elim = 10, amplitude = a)  %>%
  reshape2::melt(NULL) %>% 
  dplyr::rename(X = Var1, Y = Var2) %>% 
  mutate(amplitude = a)) %>%
  bind_rows()
ggplot(sinusoidal, aes(X, Y, fill = value)) +
  geom_tile() +
  viridis::scale_fill_viridis() +
  facet_wrap(~ amplitude, scales = "free", labeller = "label_both") +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank())
```

```{r sincor, fig.cap="Spatial autocorrelogram (Moran’s I) of simulated topography."}
n <- 500
cor <- lapply(c(0.01, 0.05, 0.1, 0.5), function(a){
  t <- sinusoidal %>% 
    filter(amplitude == a) %>% 
    sample_n(n)
  pgirmess::correlog(t[c("X", "Y")], t$value, 
                     method = "Moran", nbclass = 25) %>% 
    as.data.frame() %>% 
    mutate(amplitude = a)
}) %>% 
  bind_rows()
ggplot(cor, aes(x = dist.class, y = coef, col = as.factor(amplitude))) + geom_hline(yintercept = 0) +
  geom_point(aes(alpha = p.value < 0.01)) + geom_line() +
  scale_alpha_manual("p < 0.01", values = c(0.3, 1)) + scale_x_log10() +
  geom_vline(xintercept = c(27, 53), col = "lightgrey", linetype = "dashed") +
  geom_vline(xintercept = 150, col = "lightgrey", linetype = "dotted") +
  xlab("Distance (m)") + ylab("Moran\'s I") + scale_color_discrete("Variable")
```

## Square-Diamond Topography

The square-diaond topography generator produced pretty realistic topography. 
Playing with the $rudgeness$ did not changed a lot apart from the environmental variaiton values (values scaled in the graph).
The square-diamond topography is structured positively at 0-30 cells and also around 50 cells with high rudgeness.
The correlogram of the square-diaond topography is the closer to observed TWI, but the generator includes much more randomness.

```{r squareDiamond, fig.cap="Topography generated with the Diamond-Square algorithm for a variable rudgeness and a grid of 2^6+1."}
sdt <- lapply(c(0.1, 1, 10, 100), function(r)
  squareDiamondTopography(grid = 2^6+1, rudgeness = r)  %>%
  reshape2::melt(NULL) %>% 
  dplyr::rename(X = Var1, Y = Var2) %>% 
  mutate(rudgeness = r) %>% 
    mutate(value = scale(value))) %>% 
  bind_rows()
ggplot(sdt, aes(X, Y, fill = value)) +
  geom_tile() +
  viridis::scale_fill_viridis() +
  facet_wrap(~ rudgeness, scales = "free", labeller = "label_both") +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank())
```

```{r sdtcor, fig.cap="Spatial autocorrelogram (Moran’s I) of simulated topography."}
n <- 500
cor <- lapply(c(0.1, 1, 10, 100), function(R){
  t <- sdt %>% 
    filter(rudgeness == R) %>% 
    sample_n(n)
  pgirmess::correlog(t[c("X", "Y")], t$value, 
                     method = "Moran", nbclass = 25) %>% 
    as.data.frame() %>% 
    mutate(rudgeness = R)
}) %>% 
  bind_rows()
ggplot(cor, aes(x = dist.class, y = coef, col = as.factor(rudgeness))) + geom_hline(yintercept = 0) +
  geom_point(aes(alpha = p.value < 0.01)) + geom_line() +
  scale_alpha_manual("p < 0.01", values = c(0.3, 1)) + scale_x_log10() +
  geom_vline(xintercept = c(27, 53), col = "lightgrey", linetype = "dashed") +
  geom_vline(xintercept = 150, col = "lightgrey", linetype = "dotted") +
  xlab("Distance (m)") + ylab("Moran\'s I") + scale_color_discrete("Variable")
```

## Conclusion

I think I'll use the square-diaond topography generator with high rudgeness besides the randomness.
Further testing with the simulator using global outputs could help take a decision.
