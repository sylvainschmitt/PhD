```{r setupfgd, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(kableExtra)
if(knitr:::is_html_output()) options(knitr.table.format = "html") 
if(knitr:::is_latex_output()) options(knitr.table.format = "latex") 
library(tidyverse)
library(gganimate)
library(rstan)
library(bayesplot)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
  cache = T, cache.lazy = F)
library(ecoevosimulator)
```

# Forest gap dynamics

This chapter aims to develop a forest gap dynamics generator and compare it to the forest gap dynamics observed in Parcou plots.
...

## Mortality

I first explored mortality with the code measures from Paracou censuses.
I used code 0 "arbre mort sur pied (chandelle)",
code 6 "arbre mort et tomb√© (chablis primaire)" 
and 7 "arbre mort par la chute d'un autre arbre (chablis secondaire)". 
But every small treefalls is reported, 
and this does not seem interesting compared to gaps that should have a role in *Symphonia* ecoevolutionary dynamics.
Moreover, background mortality seems not negligible compared to treefall mortality.
Last bu not least, mortality seems higly influenced by the disturbance experiment. 

```{r plot1mortality, eval=F}
g <- src_sqlite(file.path("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/",
                     "trees", "Paracou.sqlite")) %>%
  tbl("Paracou") %>%
  filter(Plot == 1) %>%
  collect() %>% 
  mutate_at(c("CodeAlive", "CodeMeas"), as.factor) %>% 
  mutate(gaps = as.factor(as.numeric(CodeMeas %in% 6:7 & CodeAlive == 0))) %>% 
  mutate(background = as.factor(as.numeric(CodeMeas == 0 & CodeAlive == 0))) %>% 
  mutate(death = "alive") %>% 
  mutate(death = ifelse(gaps == 1, "gaps", death)) %>% 
  mutate(death = ifelse(background == 1, "background", death)) %>% 
  ggplot(aes(Xfield, Yfield, col = death, alpha = death, group = idTree)) +
  geom_point() +
  scale_color_manual("Mortality", values = c("lightgrey", "red", "blue")) +
  scale_alpha_discrete("Mortality") +
  facet_wrap(~ Plot, labeller = "label_both") +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank()) +
  transition_time(CensusYear) +
  labs(title = 'Year: {frame_time}')
anim_save("modelling_save/plot1treefalls.gif", g)
```
```{r plot1mortalitygif, fig.cap="Mortality in the Plot 1 of Paracou. In blue death on foot with code measure 0 and in red death by treefalls with code measure 6 and 7."}
include_graphics("modelling_save/plot1treefalls.gif")
```

```{r mortality, fig.cap="Background and treefall mortality per plots and census years in Paracou."}
src_sqlite(file.path("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/",
                     "trees", "Paracou.sqlite")) %>%
  tbl("Paracou") %>%
  filter(Plot != 16) %>% 
  filter(CodeAlive == 0, CodeMeas %in% c(0,6:7)) %>% 
  collect() %>% 
  mutate(Mortality = ifelse(CodeMeas == 0, "treefalls", "background")) %>% 
  group_by(CensusYear, Plot, Mortality) %>% 
  summarise(N = n()) %>% 
  filter(N > 0) %>% 
  ggplot(aes(CensusYear, N, col = as.factor(Plot), group = Plot)) +
  geom_line() +
  geom_point() +
  facet_wrap(~ Mortality, labeller = "label_both") +
  viridis::scale_color_viridis("Plot", discrete = T) +
  xlab("Census year")
```

## Backgound mortality

```{r bkgmortality}
bkgmortality <- src_sqlite(file.path("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/",
                     "trees", "Paracou.sqlite")) %>%
  tbl("Paracou") %>%
  filter(CensusYear != 1984) %>% 
  filter(Plot %in% c(1, 6, 11, 13:15)) %>% 
  filter(CodeMeas == 0 & CodeAlive == 0 | CodeAlive == 1) %>% 
  group_by(Plot, Censusyear, CodeAlive) %>% 
  summarise(N = n()) %>% 
  collect() %>% 
  mutate(CodeAlive = recode(CodeAlive, "0"= "dead", "1" = "alive")) %>% 
  reshape2::dcast(Plot + CensusYear ~ CodeAlive, value = "N") %>% 
  mutate(mortality = dead/(dead+alive)) %>% 
  na.omit()
pdeath <- round(mean(bkgmortality$mortality), 4)
```

We found a mean background mortality of $`r pdeath`year^{-1}$ in control and biodiversity plots of Paracou using code 0 "arbre mort sur pied (chandelle)".

```{r bkgmortalitygraph, fig.cap="Background mortality in control and biodiversity plots of Paracou across census years."}
ggplot(bkgmortality, aes(CensusYear, mortality, col = as.factor(Plot))) +
  geom_line() +
  geom_point() +
  geom_hline(yintercept = pdeath, col = "red", lwd = 1.1) +
  geom_text(aes(label = label), col = "red", cex  = 6,
            data = data.frame(CensusYear = 1990, mortality = 0.01, label = pdeath)) +
  viridis::scale_color_viridis("Plot", discrete = T) +
  xlab("Census year") +
  ylab("Background mortality")
```

## Neighbour crowding index

### $NCI$

I computed the neighbour crowding index (NCI) for all trees in plot 1, 6, 11 and 13 to 15 for all census years as follow:

\begin{equation} 
  NCI_{i,t} = \sum _{j~|~\delta_{i,j}<20m} ^{J_{i,t}} DBH_{j,t}^2 e^{-\frac14.\delta_{i,j}}
  (\#eq:nci)
\end{equation} 

with $DBH_{j,t}$ the diameter from neighboring tree $j$ in year $t$ and $\delta_{i,j}$ its distance to individual tree $i$.
$NCI_{i,t}$ is computed for all neighbors at a distance $\delta_{i,j}$ inferior to maximum neighboring distance of 20 meters. 
The power of neighbors $DBH$ effect was set to 2 to consider neighbors surface.
The decrease of neighbors $DBH$ effect with distance was set to 0.25 here
to represent trees at 20 meters of the focal trees having 1% of the effect of the same tree at 0  meters.

The variation of plot 1 over time seems to show rare decreases in NCI that could be related to falling trees (Fig. \@ref(fig:plotncigif)), 
as shown by the NCI trajectories of the trees in plot 1 (Fig. \@ref(fig:ncip1)), 
which include regular increases with few stochastic decreases.

```{r ncidata, eval=F}
computeNCI <- function(CensusYear, Plot, d = 20){
  if(Plot == 16) 
    stop("Xfield and Yfield doesn't work with P16.")
  trees <- src_sqlite(file.path("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/",
                                "trees", "Paracou.sqlite")) %>% 
    tbl("Paracou") %>% 
    filter(CodeAlive == 1) %>% 
    filter(Plot == local(Plot)) %>% # test for P1
    filter(CensusYear == local(CensusYear)) %>% 
    mutate(DBH = CircCorr/pi) %>%
    collect()
  D <- dist(trees[c("Xfield", "Yfield")]) %>% 
    as.matrix()
  D[D>20] <- NA # individuals above 20 m
  D[D == 0] <- NA # theimselves
  D <- exp(-0.25*D)
  D[is.na(D)] <- 0
  trees$NCI <- as.vector(D %*% as.vector(trees$DBH))
  return(trees %>% 
           filter(Xfield > local(d), Xfield < 250-local(d), Yfield > local(d), Yfield < 250-local(d)))
}
nci <- lapply(unique(bkgmortality$Plot), function(p){
  lapply(unique(bkgmortality$CensusYear), 
              function(y) computeNCI(y, p)) %>% 
  bind_rows()
}) %>% 
  bind_rows()
write_tsv(nci, path = "modelling_save/nci.tsv")
```

```{r plotnci, eval=F}
g <- read_tsv("modelling_save/nci.tsv") %>% 
  mutate( CensusYear = as.integer(CensusYear)) %>% 
  filter(Plot %in% c(1)) %>% 
  ggplot(aes(Xfield, Yfield, col = log(NCI), group = idTree)) +
  geom_point() +
  facet_wrap(~ Plot, labeller = "label_both") +
  viridis::scale_color_viridis(direction = -1) +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank()) +
   transition_time(CensusYear) +
  labs(title = 'Year: {frame_time}')
anim_save("modelling_save/nci.gif", g)
```

```{r plotncigif, fig.cap="NCI in the Plot 1 of Paracou."}
include_graphics("modelling_save/nci.gif")
```

```{r ncip1, fig.cap="NCI over census years in Plot 1."}
read_tsv("modelling_save/nci.tsv") %>% 
  filter(Plot == 1) %>%
  group_by(CensusYear) %>% 
  mutate(NCImean = mean(NCI)) %>% 
  ungroup() %>% 
  ggplot(aes(x = CensusYear)) +
  geom_line(aes(y = NCI, group = idTree), alpha = 0.1) +
  geom_line(aes(y = NCImean), col = "red", size = 2) +
  xlab("Census year") +
  ylab("Neighbour crowding index (NCI) in Plot 1") 
```

### $\delta NCI$

I then computed the NCI variation as follow:

\begin{equation} 
  \delta NCI_{i,t} = \frac{NCI_{i,t} - NCI_{i,t-1}}{t - (t-1)}
  (\#eq:deltanci)
\end{equation} 

with $NCI_{i,t}$ and $NCI_{i,t-1}$ the neighbour crowding index in censuses $t$ and $t-1$,
*beware* $t - (t-1)$ can be longer than one year for censuses seperated by more than one year.
I tested to model the distribution of $NCI$ and $\delta NCI$ as a mixture of two normals distribution using `mixtools`:
(i) intermediate and stable $NCI$ or $\delta NCI$ in the forest,
and (ii) low $NCI$ or $\delta NCI$ in or close to forest gaps.
$NCI$ did not give a good results and seems more related to a unique distribution;
whereas $detla NCI$ can be simulated as two normal distributions (Fig.\@ref(fig:mixture)):
(i) a narrow and positive normal corresponding to intermediate and stable patch of the forest,
and (ii) a  wide and negative normal corresponding to trees in or close to forest gaps.
I thus defined a threshold of $\delta NCI=-1.406$ to identify gaps corresponding to the 0.001 quantile of the narrow distribution (more than 99.9% of the dsitribution is not considered as gaps.)

```{r mixture, message=FALSE, warning=FALSE, fig.cap="Test of normal distribution mixture for NCI and deltaNCI."}
nci <- read_tsv("modelling_save/nci.tsv") %>% 
  group_by(idTree) %>% 
  arrange(CensusYear) %>% 
  mutate(deltaNCI = (NCI - lag(NCI))/(CensusYear - lag(CensusYear)),
         NCIlag = lag(NCI)) %>% 
  ungroup() %>% 
  na.omit()
ncimix <- mixtools::normalmixEM(nci$NCI, k = 2, maxit = 100, verb = F)
deltancimix <- mixtools::normalmixEM(nci$deltaNCI, k = 2, verb = F)
gnci <- ggplot(nci, aes(x = NCI)) +
  geom_histogram(aes(y = ..density..), fill = "lightgrey", col = "grey", bins = 100)  +
  stat_function(fun = dnorm, args = list(mean = ncimix$mu[1], sd = ncimix$sigma[1]), col = "red") +
  stat_function(fun = dnorm, args = list(mean = ncimix$mu[2], sd = ncimix$sigma[2]), col = "black") +
  xlab(expression(NCI))
gdeltanci <- ggplot(nci, aes(x = deltaNCI)) +
  geom_histogram(aes(y = ..density..), fill = "lightgrey", col = "grey", bins = 100)  +
  stat_function(fun = dnorm, args = list(mean =  deltancimix$mu[1], sd =  deltancimix$sigma[1]), col = "red") +
  stat_function(fun = dnorm, args = list(mean =  deltancimix$mu[2], sd =  deltancimix$sigma[2]), col = "black") +
  geom_vline(xintercept = qnorm(0.01, mean = deltancimix$mu[2], sd = deltancimix$sigma[2]), linetype = "dashed") +
  geom_text(aes(label = q0.01, y = y),
            data.frame(deltaNCI = -2, y = 0.4, 
                       q0.01 = round(qnorm(0.001, mean = deltancimix$mu[2], sd = deltancimix$sigma[2]), 3))) +
  xlim(-10, 10) +
  xlab(expression(delta[NCI]))
cowplot::plot_grid(gnci, gdeltanci, nrow = 2)
```

```{r deltancip12015low, fig.cap="deltaNCI below the threshold.", fig.height=8, fig.width=8}
nci %>% 
  # mutate(gaps = as.factor(as.numeric(deltaNCI < -1.406))) %>% 
    mutate(gaps = as.factor(as.numeric(deltaNCI < -35))) %>% 
  filter(Plot %in% 1:11) %>% 
  filter(CensusYear %in% 2013:2015) %>% 
  ggplot(aes(Xfield, Yfield, col = deltaNCI, 
             group = idTree, alpha = gaps)) +
  geom_point() +
  facet_grid(CensusYear ~ Plot, labeller = "label_both") +
  viridis::scale_color_viridis(expression(delta[NCI]), direction = -1) +
  scale_alpha_discrete(guide = "none") +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank())
```

```{r deltancip1, eval=F}
g <- read_tsv("modelling_save/nci.tsv") %>% 
  mutate(CensusYear = as.integer(CensusYear)) %>% 
  filter(Plot %in% c(1)) %>% 
  group_by(idTree) %>% 
  arrange(CensusYear) %>% 
  mutate(deltaNCI = (NCI - lag(NCI))/(CensusYear - lag(CensusYear)),
         NCIlag = lag(NCI)) %>% 
  ungroup() %>% 
  na.omit() %>% 
   # mutate(gaps = as.factor(as.numeric(deltaNCI < -1.406))) %>% 
     mutate(gaps = as.factor(as.numeric(deltaNCI < -35))) %>% 
  ggplot(aes(Xfield, Yfield, col = deltaNCI, 
             group = idTree, alpha = gaps)) +
  geom_point() +
  facet_wrap(~ Plot, labeller = "label_both") +
  viridis::scale_color_viridis(expression(delta[NCI]), direction = -1) +
  scale_alpha_discrete(guide = "none") +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank()) +
   transition_time(CensusYear) +
  labs(title = 'Year: {frame_time}')
anim_save("modelling_save/deltanci.gif", g)
```

```{r deltancip1gif, fig.cap="Negative variation of NCI in the Plot 1 of Paracou for values below threshold."}
include_graphics("modelling_save/deltanci.gif")
```

### Clustering

I then used `dbscan` for nearest-neighbour clustering in every plot and census year.
I needed to chose a distance threshold to define cluster.
Looking at point sorted by distance (Fig. \@ref(fig:kNNdist)), 
it seems that we had a good "knee" in the distribution after 10 meters.
I thus clustered defined gaps using the threshold of a maximum nearest neighbour of 10 meters,
the result seems okay (Fig. \@ref(fig:gaps)).
But the methods resulted in numerous gaps across time in Plot 1 (Fig. \@ref(fig:gapsp1gif)).

```{r kNNdist, fig.cap="k-Nearest Neighbor Distance plot."}
nci %>% 
  # filter(deltaNCI < -1.406) %>% 
  filter(deltaNCI < -35) %>% 
  group_by(Plot, CensusYear) %>% 
  do(d = data.frame(d = dbscan::kNNdist(.[c("Xfield", "Yfield")], k = 3)) %>% 
       arrange(d) %>% 
       mutate(point = 1:n())) %>% 
  unnest(d) %>% 
  ggplot(aes(point, d, col = CensusYear,
             group = as.factor(CensusYear))) + 
  geom_line() +
  geom_hline(yintercept = 10, linetype = "dashed") +
  xlab("Points sorted by distance") +
  ylab("3-NN distance") +
  facet_wrap(~ Plot, labeller = "label_both") +
  viridis::scale_color_viridis()
```

```{r gapsdata, eval=F}
nci %>% 
  # filter(deltaNCI < -1.406) %>% 
    filter(deltaNCI < -35) %>% 
  group_by(Plot, CensusYear) %>% 
  do(gaps = data.frame(idTree = .$idTree, gap = 1,
                       group = dbscan::dbscan(.[c("Xfield", "Yfield")], eps = 10, minPts = 3)$cluster)) %>% 
  unnest(gaps) %>% 
  ungroup() %>% 
  write_tsv(path = "modelling_save/gaps.tsv")
```

```{r gaps, fig.height=8, fig.width=8, fig.cap="Identified gaps with clustering."}
nci %>% 
  left_join(read_tsv("modelling_save/gaps.tsv")) %>% 
  filter(Plot %in% 1:11) %>% 
  filter(CensusYear %in% 2013:2015) %>% 
  ggplot(aes(Xfield, Yfield, col = as.factor(group), 
             group = idTree)) +
  geom_point() +
  facet_grid(CensusYear ~ Plot, labeller = "label_both") +
  viridis::scale_color_viridis("Gap", direction = -1, discrete = T) +
  scale_alpha_discrete(guide = "none") +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank(), panel.border = element_rect(color="black", fill=NA))
```

```{r gapsp1, eval=F}
g <- read_tsv("modelling_save/nci.tsv") %>% 
  left_join(read_tsv("modelling_save/gaps.tsv")) %>% 
  filter(Plot == 1) %>% 
  na.omit() %>% 
  mutate(CensusYear = as.integer(CensusYear)) %>% 
  ggplot(aes(Xfield, Yfield, col = as.factor(group), 
             group = idTree)) +
  geom_point() +
  facet_wrap(~ Plot, labeller = "label_both") +
  viridis::scale_color_viridis("Gap", direction = -1, discrete = T) +
  scale_alpha_discrete(guide = "none") +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank()) +
   transition_time(CensusYear) +
  labs(title = 'Year: {frame_time}')
anim_save("modelling_save/gaps.gif", g)
```

```{r gapsp1gif, fig.cap="Gaps in the Plot 1 of Paracou for values below threshold."}
include_graphics("modelling_save/gaps.gif")
```

## Canopy height model 

**I kept this paragraph as a reminder but I decided to not use canopy hieght model in the end.**

Another way to identify forest gaps is to use canopy height models (CHM) from Lidar campaign.
I used the R pacakge [`ForestGapR`](https://github.com/carlos-alberto-silva/ForestGapR) [@Silva2019] with CHM from 2004, 2009, and 2013 to detect forest gaps in Paracou undisturbed plots (P1, P6, P11, P13, P14, and P15). 
I defined gaps with a height below 10$m$ and a gaps size between 10$m^2$ and 1$ha$ (following @Hunter2015, Fig. \@ref(fig:CHM2014)).
I linked canopy height and inclusion in gaps for censused trees of corresponding censuses,
using 2003 census to correspond to 2004 Lidar campaign (no tree census in 2004).
A significant relation (LM, $p < 0.001$) exist between NCI and canopy height in every plot and lidar campaigns but with low variation explained ($R^2=4\%$, Fig. \@ref(fig:canpynci)).
Moreover, NCI showed a significant difference of groups (KW, $p<0.001$) between forest gaps and closed canopy (Fig. \@ref(fig:gapsnci)A),
but a non-negligible overlap exists.
I arbitrarily defined the NCI threshold to 100 (intersection between the two densities, Fig. \@ref(fig:gapsnci)B), 
but this would result in numerous gaps misenditifications. 
**Consequently, the question: "how do we define spatially, temporally, and in term of NCI variation the treefall gaps" stays.**

```{r chmdata, eval=F}
library(raster)
library(viridis)
library(ForestGapR)

# parameters
crs <- '+proj=utm +zone=22 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0'
path <- "../../data/Paracou"

# Paracou
paracou <- src_sqlite(file.path(path, "trees", "Paracou.sqlite")) %>% 
  tbl("Paracou") %>% 
  filter(CodeAlive == 1) %>% 
  filter(CensusYear %in% c(2003, 2009, 2013)) %>%
  collect()
coordinates(paracou) <- ~Xutm + Yutm
proj4string(paracou) <- crs

# CHM
dem <- raster(file.path(path, "topography", "DEM_1m_2015.tif"))
canopy2004 <- raster(file.path(path, "biotic", "Paracou2004_MNC1m.asc"))
crs(canopy2004) <- crs(dem)
canopy2004 <- projectRaster(canopy2004, crs = crs)
canopy2004<- crop(canopy2004, paracou)
canopy2009 <- raster(file.path(path, "biotic", "MNC_ParacouAvril2009_1m.tif"))
crs(canopy2009) <- crs(dem)
canopy2009 <- projectRaster(canopy2009, crs = crs)
canopy2009 <- crop(canopy2009, canopy2004) # canopy2004 smaller than the others !
canopy2013 <- raster(file.path(path, "biotic", "ParacouMNS1m2013.asc"))
dem2013 <- raster(file.path(path, "biotic", "ParacouMNT1m2013.asc"))  
canopy2013 <- canopy2013 - dem2013
crs(canopy2013) <- crs(dem)
canopy2013 <- projectRaster(canopy2013, crs = crs)
canopy2013 <- crop(canopy2013, canopy2004) # canopy2004 smaller than the others !
canopy <- stack(canopy2004, canopy2009, canopy2013)
names(canopy) <- c("CHM 2004", "CHM 2009", "CHM 2013")
plot(canopy, col = viridis(10))

# Detecting forest gaps
gaps <- lapply(as.list(canopy), getForestGaps, 10, c(10,1000))
names(gaps) <- c("gaps.2004", "gaps.2009", "gaps.2013")
plot(canopy$CHM.2004, main = "Forest Canopy Gap - 2004 - Plot 1", col = viridis(10))
plot(gaps$gaps.2004, add = T, col = "red", legend = F)

# extracting informations
canopy.df <- as.data.frame(raster::extract(canopy, paracou)) %>% 
  mutate(idTree = paracou@data$idTree, CensusYear = paracou@data$CensusYear) %>% 
  reshape2::melt(id.vars = c("idTree", "CensusYear"), variable.name = "LidarYear", value.name = "canopy") %>% 
  mutate(LidarYear = as.numeric(gsub("CHM.", "", LidarYear))) %>% 
  mutate(LidarYearAdj = ifelse(LidarYear == 2004, 2003, LidarYear)) %>% 
  filter(CensusYear == LidarYearAdj) %>% 
  dplyr::select(-LidarYearAdj)
gaps.df <- lapply(gaps, function(g)
  raster::extract(g, paracou)) %>% 
    bind_cols() %>% 
    mutate_all(funs(as.numeric(!is.na(.)))) %>% 
  mutate(idTree = paracou@data$idTree, CensusYear = paracou@data$CensusYear) %>% 
  reshape2::melt(id.vars = c("idTree", "CensusYear"), variable.name = "LidarYear", value.name = "gap") %>% 
  mutate(LidarYear = as.numeric(gsub("gaps.", "", LidarYear))) %>% 
  mutate(LidarYearAdj = ifelse(LidarYear == 2004, 2003, LidarYear)) %>% 
  filter(CensusYear == LidarYearAdj) %>% 
  dplyr::select(-LidarYearAdj)
left_join(canopy.df, gaps.df) %>% 
  write_tsv(path = "modelling_save/canopy.tsv")
```

```{r CHM2014, fig.cap="Detection of forest gaps with canopy height model from 2004 Lidar campaign in Paracou. Gaps have been detected using ForestGapR [@Silva2019] with a maximum height of 10 m and area of 10m2."}
include_graphics("modelling_save/CHM2004.png")
```

```{r canpynci, fig.cap="Relation between canopy height and neighbour crowding index among undisturbed plots and Lidar campaigns."}
read_tsv("modelling_save/nci.tsv") %>% 
  left_join(read_tsv("modelling_save/canopy.tsv")) %>% 
  filter(!is.na(gap)) %>% 
  # lm(NCI ~ canopy, data = .) %>% summary()
  ggplot(aes(canopy, NCI, col = as.factor(gap), group = NA)) + 
  geom_point() +
  geom_smooth(method = "lm") +
  ggpubr::stat_cor() +
  xlab("Canopy height (m)") +
  ylab("Neighbour crowding index") +
  scale_color_manual("Gap", values = c("darkgrey", "firebrick")) +
  facet_grid(Plot ~ CensusYear + LidarYear, scales = "free", labeller = "label_both") +
  scale_x_sqrt()
```

```{r gapsnci, fig.cap="Relation neighbour crowding index and forest gaps among undisturbed plots and years."}
g1 <- read_tsv("modelling_save/nci.tsv") %>% 
  left_join(read_tsv("modelling_save/canopy.tsv")) %>% 
  filter(!is.na(gap)) %>% 
  ggplot(aes(as.factor(Plot), NCI, fill = as.factor(gap))) + 
  geom_boxplot() +
  geom_hline(yintercept = 100, col = "black", linetype = "dashed") +
  xlab("Plot") + ylab("Neighbour crowding index") +
  scale_fill_manual("Gap", values = c("darkgrey", "firebrick")) +
  coord_flip()
g2 <- read_tsv("modelling_save/nci.tsv") %>% 
  left_join(read_tsv("modelling_save/canopy.tsv")) %>% 
  filter(!is.na(gap)) %>% 
  ggplot(aes(NCI, fill = as.factor(gap))) + 
  geom_density(alpha = 0.5) +
  geom_vline(xintercept = 100, col = "black", linetype = "dashed") +
  xlab("Neighbour crowding index") +
  scale_fill_manual("Gap", values = c("darkgrey", "firebrick"))
cowplot::plot_grid(g1, g2, nrow = 2, labels = LETTERS[1:2])
```
