```{r setupfgd, include=FALSE}
rm(list = ls()) ; invisible(gc()) ; set.seed(42)
library(knitr)
library(kableExtra)
if(knitr:::is_html_output()) options(knitr.table.format = "html") 
if(knitr:::is_latex_output()) options(knitr.table.format = "latex") 
library(tidyverse)
library(gganimate)
library(rstan)
library(bayesplot)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = T)
theme_set(bayesplot::theme_default())
opts_chunk$set(
  echo = F, message = F, warning = F, fig.height = 6, fig.width = 8,
  cache = T, cache.lazy = F)
library(ecoevosimulator)
```

# Forest gap dynamics

This chapter aims to develop a forest gap dynamics generator and compare it to the forest gap dynamics observed in Parcou plots.
First, we simulated back neighbour crowding index (NCI) dynamics in space and time.
Then, we simulated background and treefall mortality in relation to NCI dynamics.

## Neighbour crowding index

### $NCI$

I computed the neighbour crowding index (NCI) for all trees in plot 1, 6, 11 and 13 to 15 for all census years as follow:

\begin{equation} 
  NCI_{i,t} = \sum _{j~|~\delta_{i,j}<20m} ^{J_{i,t}} DBH_{j,t}^2 e^{-\frac14.\delta_{i,j}}
  (\#eq:nci)
\end{equation} 

with $DBH_{j,t}$ the diameter from neighboring tree $j$ in year $t$ and $\delta_{i,j}$ its distance to individual tree $i$.
$NCI_{i,t}$ is computed for all neighbors at a distance $\delta_{i,j}$ inferior to maximum neighboring distance of 20 meters. 
The power of neighbors $DBH$ effect was set to 2 to consider neighbors surface.
The decrease of neighbors $DBH$ effect with distance was set to 0.25 here
to represent trees at 20 meters of the focal trees having 1% of the effect of the same tree at 0  meters.

The variation of plot 1 over time seems to show rare decreases in NCI that could be related to falling trees (Fig. \@ref(fig:plotncigif)), 
as shown by the NCI trajectories of the trees in plot 1 (Fig. \@ref(fig:ncip1)), 
which include regular increases with few stochastic decreases and a global stable mean.
$NCI$ followed a normal distribution centered on $\mu_{NCI} = 123$ of variance $\sigma_{NCI} = 26$ 
in Plot 1 (Fig. \@ref(fig:p1spNCIdist)),
with spatially aggregated clusters on 10 meters or $d_{NCI} = 3$ cells (Fig. \@ref(fig:spcornci)).
We thus defined NCI distribution for initialization as:

\begin{equation} 
 NCI \sim \left\{
    \begin{array}{ll}
        \mathcal N(\mu_{NCI} = 123, \sigma_{NCI} = 26) \\
        d_{NCI}=3 & \mbox{Spatial aggregation}
    \end{array}
\right.
\end{equation} 

To simulate back NCI dynamics we chose to study the spatio-temporal dynamics of NCI variation. 

```{r ncidata, eval=F}
computeNCI <- function(CensusYear, Plot, d = 20){
  if(Plot == 16) 
    stop("Xfield and Yfield doesn't work with P16.")
  trees <- src_sqlite(file.path("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/",
                                "trees", "Paracou.sqlite")) %>% 
    tbl("Paracou") %>% 
    filter(CodeAlive == 1) %>% 
    filter(Plot == local(Plot)) %>% # test for P1
    filter(CensusYear == local(CensusYear)) %>% 
    mutate(DBH = CircCorr/pi) %>%
    collect()
  D <- dist(trees[c("Xfield", "Yfield")]) %>% 
    as.matrix()
  D[D>20] <- NA # individuals above 20 m
  D[D == 0] <- NA # theimselves
  D <- exp(-0.25*D)
  D[is.na(D)] <- 0
  trees$NCI <- as.vector(D %*% as.vector(trees$DBH))
  return(trees %>% 
           filter(Xfield > local(d), Xfield < 250-local(d), Yfield > local(d), Yfield < 250-local(d)))
}
nci <- lapply(unique(bkgmortality$Plot), function(p){
  lapply(unique(bkgmortality$CensusYear), 
              function(y) computeNCI(y, p)) %>% 
  bind_rows()
}) %>% 
  bind_rows()
write_tsv(nci, path = "modelling_save/nci.tsv")
```

```{r plotnci, eval=F}
g <- read_tsv("modelling_save/nci.tsv") %>% 
  mutate( CensusYear = as.integer(CensusYear)) %>% 
  filter(Plot %in% c(1)) %>% 
  ggplot(aes(Xfield, Yfield, col = log(NCI), group = idTree)) +
  geom_point() +
  facet_wrap(~ Plot, labeller = "label_both") +
  viridis::scale_color_viridis(direction = -1) +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank()) +
   transition_time(CensusYear) +
  labs(title = 'Year: {frame_time}')
anim_save("modelling_save/nci.gif", g)
```

```{r plotncigif, fig.cap="NCI in the Plot 1 of Paracou."}
include_graphics("modelling_save/nci.gif")
```

```{r ncip1, fig.cap="NCI over census years in Plot 1."}
read_tsv("modelling_save/nci.tsv") %>% 
  filter(Plot == 1) %>%
  group_by(CensusYear) %>% 
  mutate(NCImean = mean(NCI)) %>% 
  ungroup() %>% 
  ggplot(aes(x = CensusYear)) +
  geom_line(aes(y = NCI, group = idTree), alpha = 0.1) +
  geom_line(aes(y = NCImean), col = "red", size = 2) +
  xlab("Census year") +
  ylab("Neighbour crowding index (NCI) in Plot 1") 
```

```{r p1spNCIdist, fig.cap="Plot1 NCI distribution in space and absolute."}
t <-  read_tsv("modelling_save/nci.tsv") %>% 
  filter(Plot == 1, CensusYear == 2014) %>% 
  rename(X = Xfield, Y = Yfield)
mu <- MASS::fitdistr(t$NCI, "normal")$estimate[1]
sigma <- MASS::fitdistr(t$NCI, "normal")$estimate[2]
g1 <- ggplot(t, aes(x = NCI)) +
  geom_histogram(aes(y = ..density..), fill = "lightgrey", col = "grey", bins = 100) +
  stat_function(fun = dnorm , args = list(mean = mu, sd = sigma)) +
  geom_vline(xintercept = mu, linetype = "dashed") +
  geom_text(aes(y = y), label = "Normal", data = data.frame(NCI = 180, y = 0.015)) +
  geom_text(aes(y = y), label = expression(mu), data = data.frame(NCI = 180, y = 0.013)) +
  geom_text(aes(y = y), label = round(mu,3), data = data.frame(NCI = 180, y = 0.010)) +
  geom_text(aes(y = y), label = expression(sigma), data = data.frame(NCI = 180, y = 0.008)) +
  geom_text(aes(y = y), label = round(sigma,3), data = data.frame(NCI = 180, y = 0.005)) +
  xlab("NCI")
g2 <- ggplot(t, aes(X, Y, col = NCI)) +
  geom_point() +
  viridis::scale_color_viridis(direction = -1) +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank())
cowplot::plot_grid(g1, g2)
```

```{r spcornci, fig.cap="Spatial autocorrelation of NCI."}
nci.cor <- pgirmess::correlog(t[c("X", "Y")], t$NCI, method = "Moran", nbclass = 100)
t <- as.data.frame(nci.cor) %>% 
  filter(dist.class < 20) %>% 
  mutate(coef = round(1000*coef)) %>% 
  group_by(dist.class) %>% 
  expand(coef = 1:coef)
lambdacor <- MASS::fitdistr(t$dist.class, "exponential")$estimate
nci.cor %>% 
  as.data.frame() %>% 
  filter(dist.class < 200) %>% 
  ggplot(aes(x = dist.class, y = coef)) + 
  geom_point(aes(alpha = p.value < 0.01)) + geom_line() +
  scale_alpha_manual("p < 0.01", values = c(0.3, 1)) +
  geom_vline(xintercept = 9, col = "black", linetype = "dashed") +
  xlab("Distance (m)") + ylab("Moran\'s I") +
  scale_color_discrete(expression(delta[NCI])) +
  stat_function(fun = function(x) exp(-lambdacor*x), col = "black") +
  geom_text(label = "Exponential", col = "black",
            data = data.frame(dist.class = 50, coef = 0.5, type = "positive")) +
  geom_text(label = expression(lambda),  col = "black",
            data = data.frame(dist.class = 50, coef = 0.4, type = "positive")) +
  geom_text(label = round(lambdacor,3),  col = "black",
            data = data.frame(dist.class = 50, coef = 0.3, type = "positive"))
```

### $\delta NCI$

We computed the NCI variation as follow:

\begin{equation} 
  \delta NCI_{i,t} = \frac{NCI_{i,t} - NCI_{i,t-1}}{t - (t-1)}
  (\#eq:deltanci)
\end{equation} 

with $NCI_{i,t}$ and $NCI_{i,t-1}$ the neighbour crowding index in censuses $t$ and $t-1$,
*beware* $t - (t-1)$ can be longer than one year for censuses seperated by more than one year.
$\delta NCI$ had a normal distribution but inflated in zero (Fig. \@ref(fig:deltaNCIdistribution)).
We decided to split the distribution in two with a defined probability $p$ (Fig. \@ref(fig:deltaNCIdistribution)):
(i) $\delta NCI>0$ representing trees in growing patches following a lognormal distribution of parameters $\mu$ and $\sigma$,
(ii) $\delta NCI \leq 0$ representing trees in or near treefalls following an exponential distribution of parameter $\lambda$,
with spatially aggregated clusters on 10 meters or $d_{\delta NCI} = 3$ cells (Fig. \@ref(fig:spcor)).
We thus defined NCI distribution for as:

\begin{equation} 
\delta NCI \sim \left\{
    \begin{array}{ll}
        P(\delta NCI > 0) \sim \mathcal B(p_{\delta NCI} = 1 - 0.271) \\
        \mathcal {logN} (\mu_{\delta NCI > 0} = 0.749, \sigma_{\delta NCI > 0} = 2.651) & \mbox{if } \delta NCI > 0 \\
        \mathcal {Exp} (\lambda_{\delta NCI \leq 0} = 123) & \mbox{ifelse} \\
        d_{\delta NCI}=3 & \mbox{Spatial aggregation}
    \end{array}
\right.
\end{equation} 

```{r deltaNCIdistribution, fig.cap="Delta NCI distribution."}
nci <- read_tsv("modelling_save/nci.tsv") %>% 
  group_by(idTree) %>% 
  arrange(CensusYear) %>% 
  mutate(deltaNCI = (NCI - lag(NCI))/(CensusYear - lag(CensusYear)),
         NCIlag = lag(NCI)) %>% 
  ungroup() %>% 
  na.omit()
nci.pos <- filter(nci, deltaNCI > 0)
nci.neg <- filter(nci, deltaNCI <= 0)
p <- nrow(nci.neg)/nrow(nci)
mu <- MASS::fitdistr(nci$deltaNCI, "normal")$estimate[1]
sigma <- MASS::fitdistr(nci$deltaNCI, "normal")$estimate[2]
mulog <- MASS::fitdistr(nci.pos$deltaNCI, "lognormal")$estimate[1]
sigmalog <- MASS::fitdistr(nci.pos$deltaNCI, "lognormal")$estimate[2]
lambda <- MASS::fitdistr(-filter(nci, deltaNCI <= 0)$deltaNCI, "exponential")$estimate
g.deltaNCI <- ggplot(nci, aes(x = deltaNCI)) +
  geom_histogram(aes(y = ..density..), fill = "lightgrey", col = "grey", bins = 100)  +
  stat_function(fun = dnorm , args = list(mean = mu, sd = sigma)) +
  geom_vline(xintercept = mu, linetype = "dashed") +
  geom_text(aes(y = y), label = "Normal", data = data.frame(deltaNCI = 30, y = 0.25)) +
  geom_text(aes(y = y), label = expression(mu), data = data.frame(deltaNCI = 30, y = 0.2)) +
  geom_text(aes(y = y), label = round(mu,3), data = data.frame(deltaNCI = 30, y = 0.15)) +
    geom_text(aes(y = y), label = expression(sigma), data = data.frame(deltaNCI = 30, y = 0.10)) +
  geom_text(aes(y = y), label = round(sigma,3), data = data.frame(deltaNCI = 30, y = 0.05)) +
  xlab(expression(delta[NCI]))
g.deltaNCI.hist <- ggplot(nci, aes(x = deltaNCI > 0, fill = deltaNCI > 0)) +
  geom_bar() +
  scale_fill_manual(expression(delta[NCI] > 0), values = c("firebrick", "grey")) +
  theme(axis.line.x = element_blank(), axis.text.x = element_blank(),
        axis.title.x = element_blank(), axis.ticks.x = element_blank()) +
  geom_text(data = data.frame(deltaNCI = -1), aes(y = 2.5*10^5), label = expression(p)) +
  geom_text(data = data.frame(deltaNCI = -1), aes(y = 2*10^5), label = round(p,3))
g.deltaNCI.positive <- ggplot(nci.pos, aes(x = deltaNCI)) +
  geom_histogram(aes(y = ..density..), fill = "lightgrey", col = "grey", bins = 100)  +
  stat_function(fun = dlnorm , args = list(meanlog = mulog, sdlog = sigmalog)) +
  geom_vline(xintercept = exp(mu), linetype = "dashed") +
  geom_text(aes(y = y), label = "Logormal", data = data.frame(deltaNCI = 20, y = 0.5)) +
  geom_text(aes(y = y), label = expression(mu), data = data.frame(deltaNCI = 20, y = 0.4)) +
  geom_text(aes(y = y), label = round(exp(mulog),3), data = data.frame(deltaNCI = 20, y = 0.3)) +
    geom_text(aes(y = y), label = expression(sigma), data = data.frame(deltaNCI = 20, y = 0.2)) +
  geom_text(aes(y = y), label = round(exp(sigmalog),3), data = data.frame(deltaNCI = 20, y = 0.1)) +
  xlab(expression(delta[NCI]>0))
g.deltaNCI.negative <- ggplot(nci.neg, aes(x = -deltaNCI)) +
  geom_histogram(aes(y = ..density..), fill = "lightgrey", col = "grey", bins = 100)  +
  stat_function(fun = dexp , args = list(rate = lambda)) +
  geom_vline(xintercept = lambda, linetype = "dashed") +
  geom_text(aes(y = y), label = "Exponential", data = data.frame(deltaNCI = -50, y = 0.25)) +
  geom_text(aes(y = y), label = expression(lambda), data = data.frame(deltaNCI = -50, y = 0.2)) +
  geom_text(aes(y = y), label = round(lambda,3), data = data.frame(deltaNCI = -50, y = 0.15)) +
  xlab(expression(-delta[NCI] <= 0))
cowplot::plot_grid(g.deltaNCI, g.deltaNCI.hist, g.deltaNCI.negative, g.deltaNCI.positive)
```

```{r spcor, fig.cap="Spatial autocorrelation of deltaNCI."}
# nci.pos.2015 <- filter(nci.pos, CensusYear == 2015) %>% 
#   filter(Plot == 1)
# nci.pos.2015.cor <- pgirmess::correlog(nci.pos.2015[c("Xfield", "Yfield")], nci.pos.2015$deltaNCI, method = "Moran", nbclass = 100)
# nci.neg.2015 <- filter(nci.neg, CensusYear == 2015) %>% 
#   filter(Plot == 1)
# nci.neg.2015.cor <- pgirmess::correlog(nci.neg.2015[c("Xfield", "Yfield")], nci.neg.2015$deltaNCI, method = "Moran", nbclass = 100)
# nci.cor <- bind_rows(mutate(as.data.frame(nci.pos.2015.cor), type = "positive"),
#                      mutate(as.data.frame(nci.neg.2015.cor), type = "negative"))
# write_tsv(nci.cor, "modelling_save/spcor.tsv")
t <- read_tsv("modelling_save/spcor.tsv") %>% 
  filter(dist.class < 20) %>% 
  mutate(coef = round(1000*coef)) %>% 
  group_by(dist.class) %>% 
  expand(coef = 1:coef)
lambdacor <- MASS::fitdistr(t$dist.class, "exponential")$estimate
read_tsv("modelling_save/spcor.tsv") %>% 
  as.data.frame() %>% 
  filter(dist.class < 200) %>% 
  ggplot(aes(x = dist.class, y = coef, col = type)) + 
  geom_point(aes(alpha = p.value < 0.01)) + geom_line() +
  scale_alpha_manual("p < 0.01", values = c(0.3, 1)) +
  geom_vline(xintercept = 9, col = "black", linetype = "dashed") +
  xlab("Distance (m)") + ylab("Moran\'s I") +
  scale_color_discrete(expression(delta[NCI])) +
  stat_function(fun = function(x) exp(-lambdacor*x), col = "black") +
  geom_text(label = "Exponential", col = "black",
            data = data.frame(dist.class = 50, coef = 0.5, type = "positive")) +
  geom_text(label = expression(lambda),  col = "black",
            data = data.frame(dist.class = 50, coef = 0.4, type = "positive")) +
  geom_text(label = round(lambdacor,3),  col = "black",
            data = data.frame(dist.class = 50, coef = 0.3, type = "positive"))
```

```{r p1spdNCIdist, fig.cap="Plot1 deltaNCI distribution in space and absolute."}
t <-  filter(nci, Plot == 1, CensusYear == 2014) %>% 
  rename(X = Xfield, Y = Yfield)
g1 <- ggplot(t, aes(x = deltaNCI)) +
  geom_histogram(aes(y = ..density..), fill = "lightgrey", col = "grey", bins = 100) +
  xlab(expression(delta[NCI]))
g2 <- ggplot(t, aes(X, Y, col = deltaNCI)) +
  geom_point() +
  viridis::scale_color_viridis(expression(delta[NCI]), direction = -1) +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank())
cowplot::plot_grid(g1, g2)
```

### Generator

Using the two equations:

\begin{equation} 
 NCI \sim \left\{
    \begin{array}{ll}
        \mathcal N(\mu_{NCI} = 123, \sigma_{NCI} = 26) \\
        d_{NCI}=3 & \mbox{Spatial aggregation}
    \end{array}
\right.
\end{equation} 

\begin{equation} 
\delta NCI \sim \left\{
    \begin{array}{ll}
        P(\delta NCI > 0) \sim \mathcal B(p_{\delta NCI} = 1 - 0.271) \\
        \mathcal {logN} (\mu_{\delta NCI > 0} = 0.749, \sigma_{\delta NCI > 0} = 2.651) & \mbox{if } \delta NCI > 0 \\
        \mathcal {Exp} (\lambda_{\delta NCI \leq 0} = 123) & \mbox{ifelse} \\
        d_{\delta NCI}=3 & \mbox{Spatial aggregation}
    \end{array}
\right.
\end{equation} 

We simulated back $NCI$ and $\delta NCI$ dynamics,
using random generators based on probabilistic laws,
and disaggregating a grid to the desired size of spatial aggregation ($d=3$). 
**Beware, spatial generator is currently using the `raster` package**
**and will need to be reimplemented differently if used in C++ code**.
Using inferred parameters $p_{\delta NCI}$, $\mu_{\delta NCI > 0}$, $\sigma_{\delta NCI > 0}$, and $\lambda_{\delta NCI \leq 0}$,
we succesfully simulated back $\delta NCI$ spatial distribution (Fig. \@ref(fig:simspdNCIdist)).
Using inferred parameters $\mu_{NCI}$, and $\sigma_{NCI}$,
we succesfully simulated back $NCI$ spatial distribution (Fig. \@ref(fig:simspNCIdist)).
We then initialized $NCI$ with $NCI$ generator and simulated its dynamics variation over 33 years using $\delta NCI$ generator.
We obtain satisfying variation over time and space (Fig. \@ref(fig:simulatedNCI) and Fig. \@ref(fig:simncigif)),
with the appearance of a *true* treefall in the southwest of the simulated plot around 1998.
We are thus able to simulated $NCI$ spatio-temporal dynamics based on 7 parameters (I'm merging the two $d$ into one):

\begin{equation} 
NCI_{(x,y),t} = f 
  \begin{pmatrix}
    \mu_{NCI} \\ 
    \sigma_{NCI} \\ 
    p_{\delta NCI} \\ 
    \mu_{\delta NCI > 0} \\ 
    \sigma_{\delta NCI > 0} \\ 
    \lambda_{\delta NCI \leq 0} \\ 
    d
  \end{pmatrix}
\end{equation} 

We needed then to related background and treefall mortality to $NCI$ spatio-temporal dynamics, 
and the forest gap dynamics generator was ready. 

```{r rdeltanci, echo=T}
rdeltanci <- function(
  n = 1, # number of samples
  p = 0.271, # probability to be positive
  mu = 0.749, # mu of lognormal distributon for positive deltanci
  sigma = 2.651, # sigma of lognormal distributon for positive deltanci
  lambda = 0.31 # lamnda of exponential distributon for negative deltanci
){
  samples <- rep(0, n)
  P <- rbinom(n, 1, 1 - p) == 1
  samples[P] <- rlnorm(sum(P), meanlog = log(mu), sdlog = log(sigma))
  samples[!P] <- -rexp(sum(!P), rate = lambda)
  return(samples)
}
```

```{r rspdeltanci, echo=T}
rspcor <- function(
  grid = 50, # grid size
  generator = "rdeltanci", # can be rnorm for nci
  args = list(p = 0.271, mu = 0.749, sigma = 2.651, lambda = 0.31), # arguments for the random generator
  dcor = 3 # spatial autocorrelation size (3*3m)
){
  grid2 <- ceiling(grid/dcor)
  args$n <- grid2^2
  M2 <- matrix(do.call(generator, args), 
              ncol = grid2, nrow = grid2)
  raster::as.matrix(raster::disaggregate(raster::raster(M2), dcor, method="bilinear"))[1:grid, 1:grid] %>% 
    reshape2::melt() %>% 
    rename(X = Var1, Y = Var2)
} 
```

```{r simspdNCIdist, fig.cap="Simulated deltaNCI distribution in space and absolute."}
simnci <- data.frame(deltaNCI = rdeltanci(nrow(nci)*10))
g1 <- ggplot(simnci, aes(x = deltaNCI)) +
  geom_histogram(aes(y = ..density..), fill = "lightgrey", col = "grey", bins = 100)  +
  stat_function(fun = dnorm , args = list(mean = mean(simnci$deltaNCI), 
                                          sd = sd(simnci$deltaNCI))) +
  geom_vline(xintercept = mean(simnci$deltaNCI), linetype = "dashed") +
  geom_text(aes(y = y), label = "Normal", data = data.frame(deltaNCI = 30, y = 0.25)) +
  geom_text(aes(y = y), label = expression(mu), data = data.frame(deltaNCI = 30, y = 0.2)) +
  geom_text(aes(y = y), label = round(mean(simnci$deltaNCI),3), data = data.frame(deltaNCI = 30, y = 0.15)) +
    geom_text(aes(y = y), label = expression(sigma), data = data.frame(deltaNCI = 30, y = 0.10)) +
  geom_text(aes(y = y), label = round(sd(simnci$deltaNCI),3), data = data.frame(deltaNCI = 30, y = 0.05)) +
  xlab(expression(delta[NCI])) 
t <- rspcor(grid = 50)
g2 <- ggplot(t, aes(X, Y, fill = value)) +
  geom_tile() +
  viridis::scale_fill_viridis(expression(delta[NCI]), direction = -1) +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank())
cowplot::plot_grid(g1, g2)  
```

```{r simspNCIdist, fig.cap="Simulated NCI distribution in space and absolute."}
t <- rspcor(grid = 50, generator = "rnorm", args = c(mean = 122.73, sd = 25.806), dcor = 4)
g1 <- ggplot(t, aes(x = value)) +
  geom_histogram(aes(y = ..density..), fill = "lightgrey", col = "grey", bins = 100) +
  xlab(expression(NCI))
g2 <- ggplot(t, aes(X, Y, fill = value)) +
  geom_tile() +
  viridis::scale_fill_viridis(expression(NCI), direction = -1) +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank())
cowplot::plot_grid(g1, g2)  
```

```{r simncitsv, eval=F}
t <- rspcor(grid = 50, generator = "rnorm", args = c(mean = 122.73, sd = 25.806), dcor = 4) %>% 
  mutate(CensusYear = 1984) %>% 
  mutate(deltaNCI = NA) %>% 
  rename(NCI = value)
for(y in 1985:2017){
  ty <- filter(t, CensusYear == (y - 1)) %>% 
    dplyr::select(-CensusYear, -deltaNCI) %>% 
    left_join(rspcor(grid = 50) %>% 
                mutate(CensusYear = y) %>% 
                rename(deltaNCI = value), 
              by = c("X", "Y")) %>% 
    mutate(NCI = NCI + deltaNCI)
  t <- bind_rows(t, ty) 
}
write_tsv(t, path = "modelling_save/simnci.tsv")
```

```{r simulatedNCI, fig.cap="Simulated NCI over census years."}
read_tsv("modelling_save/simnci.tsv", col_types = cols(deltaNCI = col_double())) %>% 
  mutate(idTree = paste0(X,"-",Y)) %>% 
  group_by(CensusYear) %>% 
  mutate(NCImean = mean(NCI)) %>% 
  ungroup() %>% 
  ggplot(aes(x = CensusYear)) +
  geom_line(aes(y = NCI, group = idTree), alpha = 0.1) +
  geom_line(aes(y = NCImean), col = "red", size = 2) +
  xlab("Census year") +
  ylab("Simulated Neighbour crowding index in time.") 
```

```{r simnci, eval=F}
g <- read_tsv("modelling_save/simnci.tsv", col_types = cols(deltaNCI = col_double())) %>% 
  mutate( CensusYear = as.integer(CensusYear)) %>% 
  ggplot(aes(X, Y, fill = log(NCI))) +
  geom_tile() +
  viridis::scale_fill_viridis(direction = -1) +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank()) +
  transition_time(CensusYear) +
  labs(title = 'Year: {frame_time}')
anim_save("modelling_save/simnci.gif", g)
```

```{r simncigif, fig.cap="Simulated NCI."}
include_graphics("modelling_save/simnci.gif")
```

## Mortality

We divided mortality in background mortality, primary treefall, and secondary treefall (Fig. \@ref(fig:plot1mortalitygif)).
We related mortality to tree $DBH$ and $NCI$ and $\delta NCI$ from the previous census (Fig. \@ref(fig:mortality)).
We fitted a model using the following equation:

\begin{equation} 
 P(Mortality_{year}) \sim \mathcal B(logit(\theta_{0,year}+\theta_{DBH}\times DBH+\theta_{NCI}\times NCI+\theta_{\delta NCI}\times \delta  NCI)) \\
 \theta_{0,year} \sim \mathcal N(\theta_0, \sigma_{year})
\end{equation} 

We found only effects of $deltaNCI$ (Fig. \@ref(fig:fitmortality)),
and thus obtained the following unscaled relation to simulate mortality (Tab. \@ref(tab:fitmortality2)):

\begin{equation} 
 P(Mortality|\begin{pmatrix} \theta_0 = -4.31\\ \theta_{\delta NCI} = -0.03\end{pmatrix}) \sim \mathcal B(logit(\theta_0 + \theta_{\delta NCI}  \times \delta  NCI))
\end{equation} 

```{r plot1mortality, eval=F}
g <- src_sqlite(file.path("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/",
                     "trees", "Paracou.sqlite")) %>%
  tbl("Paracou") %>%
  filter(Plot == 1) %>%
  collect() %>% 
  mutate_at(c("CodeAlive", "CodeMeas"), as.factor) %>% 
  mutate(gaps = as.factor(as.numeric(CodeMeas %in% 6:7 & CodeAlive == 0))) %>% 
  mutate(background = as.factor(as.numeric(CodeMeas == 0 & CodeAlive == 0))) %>% 
  mutate(death = "alive") %>% 
  mutate(death = ifelse(gaps == 1, "gaps", death)) %>% 
  mutate(death = ifelse(background == 1, "background", death)) %>% 
  ggplot(aes(Xfield, Yfield, col = death, alpha = death, group = idTree)) +
  geom_point() +
  scale_color_manual("Mortality", values = c("lightgrey", "red", "blue")) +
  scale_alpha_discrete("Mortality") +
  facet_wrap(~ Plot, labeller = "label_both") +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        axis.line = element_blank(), axis.ticks = element_blank()) +
  transition_time(CensusYear) +
  labs(title = 'Year: {frame_time}')
anim_save("modelling_save/plot1treefalls.gif", g)
```
```{r plot1mortalitygif, fig.cap="Mortality in the Plot 1 of Paracou. In blue death on foot with code measure 0 and in red death by treefalls with code measure 6 and 7."}
include_graphics("modelling_save/plot1treefalls.gif")
```

```{r mortality, fig.cap="Background and treefall mortality per plots and census years in Paracou."}
nci <- read_tsv("modelling_save/nci.tsv") %>% 
  left_join(src_sqlite(file.path("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/",
                     "trees", "Paracou.sqlite")) %>%
  tbl("Paracou") %>%
  dplyr::select(CensusYear) %>% 
  collect() %>% 
  unique() %>% 
  arrange(CensusYear) %>% 
  mutate(NextCensusYear = lead(CensusYear))) %>%  # current computed is the NCI before the death of individual in the enxt census
  dplyr::select(idTree, NextCensusYear, NCI) %>% 
  na.omit() %>% 
  rename(CensusYear = NextCensusYear) %>% 
  group_by(idTree) %>% 
  arrange(CensusYear) %>% 
  mutate(deltaNCI = (NCI - lag(NCI))/(CensusYear - lag(CensusYear)),
         NCIlag = lag(NCI)) %>% 
  ungroup() %>% 
  na.omit()
data <- src_sqlite(file.path("/home/sylvain//Documents/BIOGECO/PhD/data/Paracou/",
                     "trees", "Paracou.sqlite")) %>%
  tbl("Paracou") %>%
  filter(Plot %in% c(1, 6, 11, 13:15)) %>% 
  filter(CodeAlive == 1 | (CodeAlive == 0 & CodeMeas %in% c(0,6:7))) %>% 
  mutate(DBH = CircCorr/pi) %>% 
  collect() %>% 
  left_join(nci) %>% 
  na.omit() %>% 
  mutate(Code = paste0(CodeAlive, CodeMeas)) %>%
  mutate(Status = recode(Code,
                            "00" = "background",
                            "06" = "primary treefall",
                            "07" = "secondry treefall",
                            "10" = "alive",
                            "11" = "alive",
                            "12" = "alive",
                            "13" = "alive",
                            "14" = "alive",
                            "17" = "alive")) %>% 
  mutate(CensusYearInteger = as.integer(as.factor(CensusYear))) %>% 
  mutate(death = as.integer(Status != "alive"))
data %>% 
  dplyr::select(Status, CensusYear, DBH, NCI, deltaNCI) %>% 
  reshape2::melt(id.vars = "Status") %>% 
  group_by(variable) %>% 
  mutate(valueclass = cut(value, breaks = quantile(value, probs = seq(0, 1, 0.2)), 
                          include.lowest = T)) %>% 
  group_by(Status, variable, valueclass) %>% 
  summarise(N = n()) %>% 
  reshape2::dcast(variable + valueclass ~ Status) %>% 
  reshape2::melt(id.vars = c("variable", "valueclass", "alive"), 
                 variable.name = "type", value.name = "N") %>% 
  mutate(mortality = N/alive) %>% 
  ggplot(aes(valueclass, mortality, fill = type)) +
  geom_col(position = "dodge") +
  coord_flip() +
  facet_wrap(~ variable, scales = "free") +
  theme(legend.position = "bottom", axis.title = element_blank())
```

```{r fitmortality, fig.cap="Results of the model with centered data for 10^4 observations."}
# mdata <- sample_n(data, 10^4)
# model <- stan_model(file = "modelling_stan/mortality.stan")
# fit <- sampling(model, data = list(N = nrow(mdata),
#                                    Y = max(mdata$CensusYearInteger),
#                                    death = mdata$death,
#                                    year = mdata$CensusYearInteger,
#                                    DBH = as.vector(scale(mdata$DBH)),
#                                    NCI = as.vector(scale(mdata$NCI)),
#                                    deltaNCI = as.vector(scale(mdata$deltaNCI))),
#                 include = F, pars = c("theta0y"))
# mcmc_trace(fit, np = nuts_params(fit))
# mcmc_pairs(fit, np = nuts_params(fit))
# save(mdata, fit, file = "modelling_save/fitmortality0.stan")
load("modelling_save/fitmortality0.stan")
mcmc_dens(fit, regex_pars = "theta")
```

```{r fitmortality2}
# model <- stan_model(file = "modelling_stan/mortality2.stan")
# fit <- sampling(model, data = list(N = nrow(mdata),
#                                    Y = max(mdata$CensusYearInteger),
#                                    death = mdata$death,
#                                    year = mdata$CensusYearInteger,
#                                    DBH = mdata$DBH,
#                                    deltaNCI = mdata$deltaNCI),
#                 include = F, pars = c("theta0y"))
# mcmc_trace(fit, np = nuts_params(fit))
# mcmc_pairs(fit, np = nuts_params(fit))
# save(mdata, fit, file = "modelling_save/fitmortality2.stan")
load("modelling_save/fitmortality2.stan")
broom::tidyMCMC(fit, estimate.method = "median", conf.int = T, rhat = T) %>% 
  kable(caption = "Model parameters for unscaled deltaNCI and 10^4 observations.")
```

## Timesteps

We first thought to relate timesteps to forest gap dynamics,
defining the timestep as the typical time between two treefalls.
But in the end defining major treefalls is not that simple, 
and we used a different method to simulated NCI.
Consequently, we should find another method to define timesteps,
as our current definition of death rate and deltaNCI is per year.
The idea is to aoid simulating tree growth and DBH,
the main idea being that individuals are mature (reproducing) and in the canopy.
Following @Hardy2006, *Symphonia globulifera* reach maturity at $DBH_{maturity} = 17$,
that we may increase to $DBH_{maturity} = 20$ as they reported the minimum adult DBH.
Then using symcapture analysis, 
we can relate growth to time with annual growth rate parameters
$Gmax=0.53~cm.yr^{-1}$, $Dopt=25~cm$, and $Ks=0.70$,
despite we evidenced strong differences among individuals.

```{r dbhintime, fig.cap="Age at maturity since recruitment per species."}
agr <- function(dbh, gmax = 0.53, dopt = 25, Ks = 0.7)
  gmax*exp(-0.5*(log(dbh/dopt)/Ks)^2)
dbhintime <- function(ymax = 100, gmax = 0.53, dopt = 25, Ks = 0.7){
  censuses <- data.frame(year = 1, dbh = 10) %>% 
    mutate(agr = agr(dbh, gmax = gmax, dopt = dopt, Ks = Ks))
  for(t in 2:100){
    census <- filter(censuses, year == (t - 1)) %>% 
      mutate(dbh = dbh + agr) %>% 
      mutate(agr = agr(dbh, gmax = gmax, dopt = dopt, Ks = Ks)) %>% 
      mutate(year = t)
    censuses <- bind_rows(censuses, census)
  }  
  return(censuses)
}
lapply(list("S. sp.2" = 0.537, "S. globulifera" = 0.542, "S. sp.1" = 0.367), 
       function(g) dbhintime(gmax = g)) %>% 
  bind_rows(.id = "Species") %>% 
  # group_by(Species) %>% filter(dbh >= 20) %>%  filter(dbh == first(dbh))
  ggplot(aes(year, dbh, col = Species)) +
  geom_line() +
  geom_hline(yintercept = 20, linetype = "dashed") +
  geom_vline(aes(xintercept = year, col = Species), linetype = "dashed",
             data.frame(year = c(28, 28, 41), 
                        Species = c("S. sp.2", "S. globulifera", "S. sp.1"))) +
  xlab("Age since recruitment (year)") + ylab("DBH (cm)") +
  geom_text(aes(label = label), 
            data = data.frame(year = c(20, 50), dbh = 25, label = c(28, 41), 
                              Species = c("S. globulifera", "S. sp.1")))
```

Another solution is to consider a simpler timestep,
with a new individual recruited in the gaps at each censuses from the sapling pool.
